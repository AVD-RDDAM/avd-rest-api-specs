# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
from urllib.parse import parse_qs, urljoin, urlparse

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling

from ...operations._operations import (
    build_cassandra_clusters_create_update_request,
    build_cassandra_clusters_deallocate_request,
    build_cassandra_clusters_delete_request,
    build_cassandra_clusters_get_backup_request,
    build_cassandra_clusters_get_request,
    build_cassandra_clusters_invoke_command_request,
    build_cassandra_clusters_list_backups_request,
    build_cassandra_clusters_list_by_resource_group_request,
    build_cassandra_clusters_list_by_subscription_request,
    build_cassandra_clusters_start_request,
    build_cassandra_clusters_status_request,
    build_cassandra_clusters_update_request,
    build_cassandra_data_centers_create_update_request,
    build_cassandra_data_centers_delete_request,
    build_cassandra_data_centers_get_request,
    build_cassandra_data_centers_list_request,
    build_cassandra_data_centers_update_request,
    build_cassandra_resources_create_update_cassandra_keyspace_request,
    build_cassandra_resources_create_update_cassandra_table_request,
    build_cassandra_resources_create_update_cassandra_view_request,
    build_cassandra_resources_delete_cassandra_keyspace_request,
    build_cassandra_resources_delete_cassandra_table_request,
    build_cassandra_resources_delete_cassandra_view_request,
    build_cassandra_resources_get_cassandra_keyspace_request,
    build_cassandra_resources_get_cassandra_keyspace_throughput_request,
    build_cassandra_resources_get_cassandra_table_request,
    build_cassandra_resources_get_cassandra_table_throughput_request,
    build_cassandra_resources_get_cassandra_view_request,
    build_cassandra_resources_get_cassandra_view_throughput_request,
    build_cassandra_resources_list_cassandra_keyspaces_request,
    build_cassandra_resources_list_cassandra_tables_request,
    build_cassandra_resources_list_cassandra_views_request,
    build_cassandra_resources_migrate_cassandra_keyspace_to_autoscale_request,
    build_cassandra_resources_migrate_cassandra_keyspace_to_manual_throughput_request,
    build_cassandra_resources_migrate_cassandra_table_to_autoscale_request,
    build_cassandra_resources_migrate_cassandra_table_to_manual_throughput_request,
    build_cassandra_resources_migrate_cassandra_view_to_autoscale_request,
    build_cassandra_resources_migrate_cassandra_view_to_manual_throughput_request,
    build_cassandra_resources_update_cassandra_keyspace_throughput_request,
    build_cassandra_resources_update_cassandra_table_throughput_request,
    build_cassandra_resources_update_cassandra_view_throughput_request,
    build_collection_list_metric_definitions_request,
    build_collection_list_metrics_request,
    build_collection_list_usages_request,
    build_collection_partition_list_metrics_request,
    build_collection_partition_list_usages_request,
    build_collection_partition_region_list_metrics_request,
    build_collection_region_list_metrics_request,
    build_data_transfer_jobs_cancel_request,
    build_data_transfer_jobs_create_request,
    build_data_transfer_jobs_get_request,
    build_data_transfer_jobs_list_by_database_account_request,
    build_data_transfer_jobs_pause_request,
    build_data_transfer_jobs_resume_request,
    build_database_account_region_list_metrics_request,
    build_database_accounts_check_name_exists_request,
    build_database_accounts_create_or_update_request,
    build_database_accounts_delete_request,
    build_database_accounts_failover_priority_change_request,
    build_database_accounts_get_read_only_keys_request,
    build_database_accounts_get_request,
    build_database_accounts_list_by_resource_group_request,
    build_database_accounts_list_connection_strings_request,
    build_database_accounts_list_keys_request,
    build_database_accounts_list_metric_definitions_request,
    build_database_accounts_list_metrics_request,
    build_database_accounts_list_read_only_keys_request,
    build_database_accounts_list_request,
    build_database_accounts_list_usages_request,
    build_database_accounts_offline_region_request,
    build_database_accounts_online_region_request,
    build_database_accounts_regenerate_key_request,
    build_database_accounts_update_request,
    build_database_list_metric_definitions_request,
    build_database_list_metrics_request,
    build_database_list_usages_request,
    build_graph_resources_create_update_graph_request,
    build_graph_resources_delete_graph_resource_request,
    build_graph_resources_get_graph_request,
    build_graph_resources_list_graphs_request,
    build_gremlin_resources_create_update_gremlin_database_request,
    build_gremlin_resources_create_update_gremlin_graph_request,
    build_gremlin_resources_delete_gremlin_database_request,
    build_gremlin_resources_delete_gremlin_graph_request,
    build_gremlin_resources_get_gremlin_database_request,
    build_gremlin_resources_get_gremlin_database_throughput_request,
    build_gremlin_resources_get_gremlin_graph_request,
    build_gremlin_resources_get_gremlin_graph_throughput_request,
    build_gremlin_resources_list_gremlin_databases_request,
    build_gremlin_resources_list_gremlin_graphs_request,
    build_gremlin_resources_migrate_gremlin_database_to_autoscale_request,
    build_gremlin_resources_migrate_gremlin_database_to_manual_throughput_request,
    build_gremlin_resources_migrate_gremlin_graph_to_autoscale_request,
    build_gremlin_resources_migrate_gremlin_graph_to_manual_throughput_request,
    build_gremlin_resources_retrieve_continuous_backup_information_request,
    build_gremlin_resources_update_gremlin_database_throughput_request,
    build_gremlin_resources_update_gremlin_graph_throughput_request,
    build_locations_get_request,
    build_locations_list_request,
    build_mongo_db_resources_create_update_mongo_db_collection_request,
    build_mongo_db_resources_create_update_mongo_db_database_request,
    build_mongo_db_resources_create_update_mongo_role_definition_request,
    build_mongo_db_resources_create_update_mongo_user_definition_request,
    build_mongo_db_resources_delete_mongo_db_collection_request,
    build_mongo_db_resources_delete_mongo_db_database_request,
    build_mongo_db_resources_delete_mongo_role_definition_request,
    build_mongo_db_resources_delete_mongo_user_definition_request,
    build_mongo_db_resources_get_mongo_db_collection_request,
    build_mongo_db_resources_get_mongo_db_collection_throughput_request,
    build_mongo_db_resources_get_mongo_db_database_request,
    build_mongo_db_resources_get_mongo_db_database_throughput_request,
    build_mongo_db_resources_get_mongo_role_definition_request,
    build_mongo_db_resources_get_mongo_user_definition_request,
    build_mongo_db_resources_list_mongo_db_collection_partition_merge_request,
    build_mongo_db_resources_list_mongo_db_collections_request,
    build_mongo_db_resources_list_mongo_db_databases_request,
    build_mongo_db_resources_list_mongo_role_definitions_request,
    build_mongo_db_resources_list_mongo_user_definitions_request,
    build_mongo_db_resources_migrate_mongo_db_collection_to_autoscale_request,
    build_mongo_db_resources_migrate_mongo_db_collection_to_manual_throughput_request,
    build_mongo_db_resources_migrate_mongo_db_database_to_autoscale_request,
    build_mongo_db_resources_migrate_mongo_db_database_to_manual_throughput_request,
    build_mongo_db_resources_mongo_db_container_redistribute_throughput_request,
    build_mongo_db_resources_mongo_db_container_retrieve_throughput_distribution_request,
    build_mongo_db_resources_mongo_db_database_redistribute_throughput_request,
    build_mongo_db_resources_mongo_db_database_retrieve_throughput_distribution_request,
    build_mongo_db_resources_retrieve_continuous_backup_information_request,
    build_mongo_db_resources_update_mongo_db_collection_throughput_request,
    build_mongo_db_resources_update_mongo_db_database_throughput_request,
    build_notebook_workspaces_create_or_update_request,
    build_notebook_workspaces_delete_request,
    build_notebook_workspaces_get_request,
    build_notebook_workspaces_list_by_database_account_request,
    build_notebook_workspaces_list_connection_info_request,
    build_notebook_workspaces_regenerate_auth_token_request,
    build_notebook_workspaces_start_request,
    build_operations_list_request,
    build_partition_key_range_id_list_metrics_request,
    build_partition_key_range_id_region_list_metrics_request,
    build_percentile_list_metrics_request,
    build_percentile_source_target_list_metrics_request,
    build_percentile_target_list_metrics_request,
    build_private_endpoint_connections_create_or_update_request,
    build_private_endpoint_connections_delete_request,
    build_private_endpoint_connections_get_request,
    build_private_endpoint_connections_list_by_database_account_request,
    build_private_link_resources_get_request,
    build_private_link_resources_list_by_database_account_request,
    build_restorable_database_accounts_get_by_location_request,
    build_restorable_database_accounts_list_by_location_request,
    build_restorable_database_accounts_list_request,
    build_restorable_gremlin_databases_list_request,
    build_restorable_gremlin_graphs_list_request,
    build_restorable_gremlin_resources_list_request,
    build_restorable_mongodb_collections_list_request,
    build_restorable_mongodb_databases_list_request,
    build_restorable_mongodb_resources_list_request,
    build_restorable_sql_containers_list_request,
    build_restorable_sql_databases_list_request,
    build_restorable_sql_resources_list_request,
    build_restorable_table_resources_list_request,
    build_restorable_tables_list_request,
    build_service_create_request,
    build_service_delete_request,
    build_service_get_request,
    build_service_list_request,
    build_sql_resources_create_update_client_encryption_key_request,
    build_sql_resources_create_update_sql_container_request,
    build_sql_resources_create_update_sql_database_request,
    build_sql_resources_create_update_sql_role_assignment_request,
    build_sql_resources_create_update_sql_role_definition_request,
    build_sql_resources_create_update_sql_stored_procedure_request,
    build_sql_resources_create_update_sql_trigger_request,
    build_sql_resources_create_update_sql_user_defined_function_request,
    build_sql_resources_delete_sql_container_request,
    build_sql_resources_delete_sql_database_request,
    build_sql_resources_delete_sql_role_assignment_request,
    build_sql_resources_delete_sql_role_definition_request,
    build_sql_resources_delete_sql_stored_procedure_request,
    build_sql_resources_delete_sql_trigger_request,
    build_sql_resources_delete_sql_user_defined_function_request,
    build_sql_resources_get_client_encryption_key_request,
    build_sql_resources_get_sql_container_request,
    build_sql_resources_get_sql_container_throughput_request,
    build_sql_resources_get_sql_database_request,
    build_sql_resources_get_sql_database_throughput_request,
    build_sql_resources_get_sql_role_assignment_request,
    build_sql_resources_get_sql_role_definition_request,
    build_sql_resources_get_sql_stored_procedure_request,
    build_sql_resources_get_sql_trigger_request,
    build_sql_resources_get_sql_user_defined_function_request,
    build_sql_resources_list_client_encryption_keys_request,
    build_sql_resources_list_sql_container_partition_merge_request,
    build_sql_resources_list_sql_containers_request,
    build_sql_resources_list_sql_databases_request,
    build_sql_resources_list_sql_role_assignments_request,
    build_sql_resources_list_sql_role_definitions_request,
    build_sql_resources_list_sql_stored_procedures_request,
    build_sql_resources_list_sql_triggers_request,
    build_sql_resources_list_sql_user_defined_functions_request,
    build_sql_resources_migrate_sql_container_to_autoscale_request,
    build_sql_resources_migrate_sql_container_to_manual_throughput_request,
    build_sql_resources_migrate_sql_database_to_autoscale_request,
    build_sql_resources_migrate_sql_database_to_manual_throughput_request,
    build_sql_resources_retrieve_continuous_backup_information_request,
    build_sql_resources_sql_container_redistribute_throughput_request,
    build_sql_resources_sql_container_retrieve_throughput_distribution_request,
    build_sql_resources_sql_database_redistribute_throughput_request,
    build_sql_resources_sql_database_retrieve_throughput_distribution_request,
    build_sql_resources_update_sql_container_throughput_request,
    build_sql_resources_update_sql_database_throughput_request,
    build_table_resources_create_update_table_request,
    build_table_resources_delete_table_request,
    build_table_resources_get_table_request,
    build_table_resources_get_table_throughput_request,
    build_table_resources_list_tables_request,
    build_table_resources_migrate_table_to_autoscale_request,
    build_table_resources_migrate_table_to_manual_throughput_request,
    build_table_resources_retrieve_continuous_backup_information_request,
    build_table_resources_update_table_throughput_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DatabaseAccountsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`database_accounts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Retrieves the properties of an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_database_accounts_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_initial(
        self, resource_group_name: str, account_name: str, update_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_parameters, (IO, bytes)):
            _content = update_parameters
        else:
            _json = update_parameters

        request = build_database_accounts_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        account_name: str,
        update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Updates the properties of an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param update_parameters: The parameters to provide for the current database account. Required.
        :type update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # JSON input template you can fill out and use as your body input.
                update_parameters = {
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        account_name: str,
        update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Updates the properties of an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param update_parameters: The parameters to provide for the current database account. Required.
        :type update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update(
        self, resource_group_name: str, account_name: str, update_parameters: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Updates the properties of an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param update_parameters: The parameters to provide for the current database account. Is either
         a model type or a IO type. Required.
        :type update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                update_parameters=update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _create_or_update_initial(
        self, resource_group_name: str, account_name: str, create_update_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_parameters, (IO, bytes)):
            _content = create_update_parameters
        else:
            _json = create_update_parameters

        request = build_database_accounts_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        create_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB database account. The "Update" method is preferred when
        performing updates on an account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_parameters: The parameters to provide for the current database account.
         Required.
        :type create_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # JSON input template you can fill out and use as your body input.
                create_update_parameters = {
                    "properties": {
                        "databaseAccountOfferType": "Standard",  # Default value is
                          "Standard". The offer type for the database. Required.
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ]
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        create_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB database account. The "Update" method is preferred when
        performing updates on an account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_parameters: The parameters to provide for the current database account.
         Required.
        :type create_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self, resource_group_name: str, account_name: str, create_update_parameters: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB database account. The "Update" method is preferred when
        performing updates on an account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_parameters: The parameters to provide for the current database account. Is
         either a model type or a IO type. Required.
        :type create_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_or_update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                create_update_parameters=create_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_database_accounts_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete(self, resource_group_name: str, account_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _failover_priority_change_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, failover_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(failover_parameters, (IO, bytes)):
            _content = failover_parameters
        else:
            _json = failover_parameters

        request = build_database_accounts_failover_priority_change_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def begin_failover_priority_change(
        self,
        resource_group_name: str,
        account_name: str,
        failover_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Changes the failover priority for the Azure Cosmos DB database account. A failover priority of
        0 indicates a write region. The maximum value for a failover priority = (total number of
        regions - 1). Failover priority values must be unique for each of the regions in which the
        database account exists.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param failover_parameters: The new failover policies for the database account. Required.
        :type failover_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                failover_parameters = {
                    "failoverPolicies": [
                        {
                            "failoverPriority": 0,  # Optional. The failover priority of
                              the region. A failover priority of 0 indicates a write region. The
                              maximum value for a failover priority = (total number of regions - 1).
                              Failover priority values must be unique for each of the regions in which
                              the database account exists.
                            "id": "str",  # Optional. The unique identifier of the region
                              in which the database account replicates to. Example:
                              &lt;accountName&gt;-&lt;locationName&gt;.
                            "locationName": "str"  # Optional. The name of the region in
                              which the database account exists.
                        }
                    ]
                }
        """

    @overload
    async def begin_failover_priority_change(
        self,
        resource_group_name: str,
        account_name: str,
        failover_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Changes the failover priority for the Azure Cosmos DB database account. A failover priority of
        0 indicates a write region. The maximum value for a failover priority = (total number of
        regions - 1). Failover priority values must be unique for each of the regions in which the
        database account exists.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param failover_parameters: The new failover policies for the database account. Required.
        :type failover_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_failover_priority_change(
        self, resource_group_name: str, account_name: str, failover_parameters: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Changes the failover priority for the Azure Cosmos DB database account. A failover priority of
        0 indicates a write region. The maximum value for a failover priority = (total number of
        regions - 1). Failover priority values must be unique for each of the regions in which the
        database account exists.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param failover_parameters: The new failover policies for the database account. Is either a
         model type or a IO type. Required.
        :type failover_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._failover_priority_change_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                failover_parameters=failover_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists all the Azure Cosmos DB database accounts available under the subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_accounts_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists all the Azure Cosmos DB database accounts available under the given resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "Continuous":
                backup_policy = {
                    "type": "Continuous",
                    "continuousModeProperties": {
                        "tier": "str"  # Optional. Enum to indicate type of Continuos backup
                          mode. Known values are: "Continuous7Days" and "Continuous30Days".
                    },
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    }
                }

                # JSON input template for discriminator value "Periodic":
                backup_policy = {
                    "type": "Periodic",
                    "migrationState": {
                        "startTime": "2020-02-20 00:00:00",  # Optional. Time at which the
                          backup policy migration started (ISO-8601 format).
                        "status": "str",  # Optional. Describes the status of migration
                          between backup policy types. Known values are: "Invalid", "InProgress",
                          "Completed", and "Failed".
                        "targetType": "str"  # Optional. Describes the target backup policy
                          type of the backup policy migration. Known values are: "Periodic" and
                          "Continuous".
                    },
                    "periodicModeProperties": {
                        "backupIntervalInMinutes": 0,  # Optional. An integer representing
                          the interval in minutes between two backups.
                        "backupRetentionIntervalInHours": 0,  # Optional. An integer
                          representing the time (in hours) that each backup is retained.
                        "backupStorageRedundancy": "str"  # Optional. Enum to indicate type
                          of backup residency. Known values are: "Geo", "Local", and "Zone".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Indicates the type of database account. This can
                      only be set at database account creation. Known values are: "GlobalDocumentDB",
                      "MongoDB", and "Parse".
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "analyticalStorageConfiguration": {
                            "schemaType": "str"  # Optional. Describes the types of
                              schema for analytical storage. Known values are: "WellDefined" and
                              "FullFidelity".
                        },
                        "apiProperties": {
                            "serverVersion": "str"  # Optional. Describes the
                              ServerVersion of an a MongoDB account. Known values are: "3.2", "3.6",
                              "4.0", and "4.2".
                        },
                        "backupPolicy": backup_policy,
                        "capabilities": [
                            {
                                "name": "str"  # Optional. Name of the Cosmos DB
                                  capability. For example, "name": "EnableCassandra". Current values
                                  also include "EnableTable" and "EnableGremlin".
                            }
                        ],
                        "capacity": {
                            "totalThroughputLimit": 0  # Optional. The total throughput
                              limit imposed on the account. A totalThroughputLimit of 2000 imposes a
                              strict limit of max throughput that can be provisioned on that account to
                              be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning
                              of throughput.
                        },
                        "connectorOffer": "str",  # Optional. The cassandra connector offer
                          type for the Cosmos DB database C* account. "Small"
                        "consistencyPolicy": {
                            "defaultConsistencyLevel": "str",  # The default consistency
                              level and configuration settings of the Cosmos DB account. Required.
                              Known values are: "Eventual", "Session", "BoundedStaleness", "Strong",
                              and "ConsistentPrefix".
                            "maxIntervalInSeconds": 0,  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the time
                              amount of staleness (in seconds) tolerated. Accepted range for this value
                              is 5 - 86400. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                            "maxStalenessPrefix": 0  # Optional. When used with the
                              Bounded Staleness consistency level, this value represents the number of
                              stale requests tolerated. Accepted range for this value is 1 "u2013
                              2,147,483,647. Required when defaultConsistencyPolicy is set to
                              'BoundedStaleness'.
                        },
                        "cors": [
                            {
                                "allowedOrigins": "str",  # The origin domains that
                                  are permitted to make a request against the service via CORS.
                                  Required.
                                "allowedHeaders": "str",  # Optional. The request
                                  headers that the origin domain may specify on the CORS request.
                                "allowedMethods": "str",  # Optional. The methods
                                  (HTTP request verbs) that the origin domain may use for a CORS
                                  request.
                                "exposedHeaders": "str",  # Optional. The response
                                  headers that may be sent in the response to the CORS request and
                                  exposed by the browser to the request issuer.
                                "maxAgeInSeconds": 0  # Optional. The maximum amount
                                  time that a browser should cache the preflight OPTIONS request.
                            }
                        ],
                        "createMode": "Default",  # Optional. Default value is "Default".
                          Enum to indicate the mode of account creation. Known values are: "Default"
                          and "Restore".
                        "databaseAccountOfferType": "Standard",  # Optional. Default value is
                          "Standard". The offer type for the Cosmos DB database account. Default value:
                          Standard.
                        "defaultIdentity": "str",  # Optional. The default identity for
                          accessing key vault used in features like customer managed keys. The default
                          identity needs to be explicitly set by the users. It can be
                          "FirstPartyIdentity", "SystemAssignedIdentity" and more.
                        "diagnosticLogSettings": {
                            "enableFullTextQuery": "str"  # Optional. Describe the level
                              of detail with which queries are to be logged. Known values are: "None",
                              "True", and "False".
                        },
                        "disableKeyBasedMetadataWriteAccess": bool,  # Optional. Disable
                          write operations on metadata resources (databases, containers, throughput)
                          via account keys.
                        "disableLocalAuth": bool,  # Optional. Opt-out of local
                          authentication and ensure only MSI and AAD can be used exclusively for
                          authentication.
                        "documentEndpoint": "str",  # Optional. The connection endpoint for
                          the Cosmos DB database account.
                        "enableAnalyticalStorage": bool,  # Optional. Flag to indicate
                          whether to enable storage analytics.
                        "enableAutomaticFailover": bool,  # Optional. Enables automatic
                          failover of the write region in the rare event that the region is unavailable
                          due to an outage. Automatic failover will result in a new write region for
                          the account and is chosen based on the failover priorities configured for the
                          account.
                        "enableCassandraConnector": bool,  # Optional. Enables the cassandra
                          connector on the Cosmos DB C* account.
                        "enableFreeTier": bool,  # Optional. Flag to indicate whether Free
                          Tier is enabled.
                        "enableMaterializedViews": bool,  # Optional. Flag to indicate
                          whether to enable MaterializedViews on the Cosmos DB account.
                        "enableMultipleWriteLocations": bool,  # Optional. Enables the
                          account to write in multiple locations.
                        "enablePartitionMerge": bool,  # Optional. Flag to indicate
                          enabling/disabling of Partition Merge feature on the account.
                        "failoverPolicies": [
                            {
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region in which the database account replicates to. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "locationName": "str"  # Optional. The name of the
                                  region in which the database account exists.
                            }
                        ],
                        "instanceId": "str",  # Optional. A unique identifier assigned to the
                          database account.
                        "ipRules": [
                            {
                                "ipAddressOrRange": "str"  # Optional. A single IPv4
                                  address or a single IPv4 address range in CIDR format. Provided IPs
                                  must be well-formatted and cannot be contained in one of the
                                  following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12,
                                  192.168.0.0/16, since these are not enforceable by the IP address
                                  filter. Example of valid inputs: "u201c23.40.210.245"u201d or
                                  "u201c23.40.210.0/8"u201d.
                            }
                        ],
                        "isVirtualNetworkFilterEnabled": bool,  # Optional. Flag to indicate
                          whether to enable/disable Virtual Network ACL rules.
                        "keyVaultKeyUri": "str",  # Optional. The URI of the key vault.
                        "keysMetadata": {
                            "primaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "primaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            },
                            "secondaryReadonlyMasterKey": {
                                "generationTime": "2020-02-20 00:00:00"  # Optional.
                                  Generation time in UTC of the key in ISO-8601 format. If the value is
                                  missing from the object, it means that the last key regeneration was
                                  triggered before 2022-06-18.
                            }
                        },
                        "locations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "networkAclBypass": "str",  # Optional. Indicates what services are
                          allowed to bypass firewall checks. Known values are: "None" and
                          "AzureServices".
                        "networkAclBypassResourceIds": [
                            "str"  # Optional. An array that contains the Resource Ids
                              for Network Acl Bypass for the Cosmos DB account.
                        ],
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "groupId": "str",  # Optional. Group id of
                                      the private endpoint.
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. Resource id
                                          of the private endpoint.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. Any action that is required beyond basic workflow
                                          (approve/ reject/ disconnect).
                                        "description": "str",  # Optional.
                                          The private link service connection description.
                                        "status": "str"  # Optional. The
                                          private link service connection status.
                                    },
                                    "provisioningState": "str"  # Optional.
                                      Provisioning state of the private endpoint.
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the Cosmos DB
                          account at the time the operation was called. The status can be one of
                          following. 'Creating' "u2013 the Cosmos DB account is being created. When an
                          account is in Creating state, only properties that are specified as input for
                          the Create Cosmos DB account operation are returned. 'Succeeded' "u2013 the
                          Cosmos DB account is active for use. 'Updating' "u2013 the Cosmos DB account
                          is being updated. 'Deleting' "u2013 the Cosmos DB account is being deleted.
                          'Failed' "u2013 the Cosmos DB account failed creation. 'DeletionFailed'
                          "u2013 the Cosmos DB account deletion failed.
                        "publicNetworkAccess": "str",  # Optional. Whether requests from
                          Public Network are allowed. Known values are: "Enabled" and "Disabled".
                        "readLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ],
                        "restoreParameters": {
                            "databasesToRestore": [
                                {
                                    "collectionNames": [
                                        "str"  # Optional. The names of the
                                          collections available for restore.
                                    ],
                                    "databaseName": "str"  # Optional. The name
                                      of the database available for restore.
                                }
                            ],
                            "gremlinDatabasesToRestore": [
                                {
                                    "databaseName": "str",  # Optional. The name
                                      of the gremlin database available for restore.
                                    "graphNames": [
                                        "str"  # Optional. The names of the
                                          graphs available for restore.
                                    ]
                                }
                            ],
                            "restoreMode": "str",  # Optional. Describes the mode of the
                              restore. "PointInTime"
                            "restoreSource": "str",  # Optional. The id of the restorable
                              database account from which the restore has to be initiated. For example:
                              /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                            "restoreTimestampInUtc": "2020-02-20 00:00:00",  # Optional.
                              Time to which the account has to be restored (ISO-8601 format).
                            "tablesToRestore": [
                                "str"  # Optional. List of specific tables available
                                  for restore.
                            ]
                        },
                        "virtualNetworkRules": [
                            {
                                "id": "str",  # Optional. Resource ID of a subnet,
                                  for example:
                                  /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
                                "ignoreMissingVNetServiceEndpoint": bool  # Optional.
                                  Create firewall rule before the virtual network has vnet service
                                  endpoint enabled.
                            }
                        ],
                        "writeLocations": [
                            {
                                "documentEndpoint": "str",  # Optional. The
                                  connection endpoint for the specific region. Example:
                                  https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/.
                                "failoverPriority": 0,  # Optional. The failover
                                  priority of the region. A failover priority of 0 indicates a write
                                  region. The maximum value for a failover priority = (total number of
                                  regions - 1). Failover priority values must be unique for each of the
                                  regions in which the database account exists.
                                "id": "str",  # Optional. The unique identifier of
                                  the region within the database account. Example:
                                  &lt;accountName&gt;-&lt;locationName&gt;.
                                "isZoneRedundant": bool,  # Optional. Flag to
                                  indicate whether or not this region is an AvailabilityZone region.
                                "locationName": "str",  # Optional. The name of the
                                  region.
                                "provisioningState": "str"  # Optional. The status of
                                  the Cosmos DB account at the time the operation was called. The
                                  status can be one of following. 'Creating' "u2013 the Cosmos DB
                                  account is being created. When an account is in Creating state, only
                                  properties that are specified as input for the Create Cosmos DB
                                  account operation are returned. 'Succeeded' "u2013 the Cosmos DB
                                  account is active for use. 'Updating' "u2013 the Cosmos DB account is
                                  being updated. 'Deleting' "u2013 the Cosmos DB account is being
                                  deleted. 'Failed' "u2013 the Cosmos DB account failed creation.
                                  'DeletionFailed' "u2013 the Cosmos DB account deletion failed.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_accounts_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_keys(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Lists the access keys for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "primaryMasterKey": "str",  # Optional. Base 64 encoded value of the primary
                      read-write key.
                    "primaryReadonlyMasterKey": "str",  # Optional. Base 64 encoded value of the
                      primary read-only key.
                    "secondaryMasterKey": "str",  # Optional. Base 64 encoded value of the
                      secondary read-write key.
                    "secondaryReadonlyMasterKey": "str"  # Optional. Base 64 encoded value of the
                      secondary read-only key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_database_accounts_list_keys_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list_connection_strings(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Lists the connection strings for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "connectionStrings": [
                        {
                            "connectionString": "str",  # Optional. Value of the
                              connection string.
                            "description": "str"  # Optional. Description of the
                              connection string.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_database_accounts_list_connection_strings_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _offline_region_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, region_parameter_for_offline: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(region_parameter_for_offline, (IO, bytes)):
            _content = region_parameter_for_offline
        else:
            _json = region_parameter_for_offline

        request = build_database_accounts_offline_region_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def begin_offline_region(
        self,
        resource_group_name: str,
        account_name: str,
        region_parameter_for_offline: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Offline the specified region for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region_parameter_for_offline: Cosmos DB region to offline for the database account.
         Required.
        :type region_parameter_for_offline: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                region_parameter_for_offline = {
                    "region": "str"  # Cosmos DB region, with spaces between words and each word
                      capitalized. Required.
                }
        """

    @overload
    async def begin_offline_region(
        self,
        resource_group_name: str,
        account_name: str,
        region_parameter_for_offline: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Offline the specified region for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region_parameter_for_offline: Cosmos DB region to offline for the database account.
         Required.
        :type region_parameter_for_offline: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_offline_region(
        self, resource_group_name: str, account_name: str, region_parameter_for_offline: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Offline the specified region for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region_parameter_for_offline: Cosmos DB region to offline for the database account. Is
         either a model type or a IO type. Required.
        :type region_parameter_for_offline: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._offline_region_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                region_parameter_for_offline=region_parameter_for_offline,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _online_region_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, region_parameter_for_online: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(region_parameter_for_online, (IO, bytes)):
            _content = region_parameter_for_online
        else:
            _json = region_parameter_for_online

        request = build_database_accounts_online_region_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def begin_online_region(
        self,
        resource_group_name: str,
        account_name: str,
        region_parameter_for_online: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Online the specified region for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region_parameter_for_online: Cosmos DB region to online for the database account.
         Required.
        :type region_parameter_for_online: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                region_parameter_for_online = {
                    "region": "str"  # Cosmos DB region, with spaces between words and each word
                      capitalized. Required.
                }
        """

    @overload
    async def begin_online_region(
        self,
        resource_group_name: str,
        account_name: str,
        region_parameter_for_online: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Online the specified region for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region_parameter_for_online: Cosmos DB region to online for the database account.
         Required.
        :type region_parameter_for_online: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_online_region(
        self, resource_group_name: str, account_name: str, region_parameter_for_online: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Online the specified region for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region_parameter_for_online: Cosmos DB region to online for the database account. Is
         either a model type or a IO type. Required.
        :type region_parameter_for_online: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._online_region_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                region_parameter_for_online=region_parameter_for_online,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_read_only_keys(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Lists the read-only access keys for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "primaryReadonlyMasterKey": "str",  # Optional. Base 64 encoded value of the
                      primary read-only key.
                    "secondaryReadonlyMasterKey": "str"  # Optional. Base 64 encoded value of the
                      secondary read-only key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_database_accounts_get_read_only_keys_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list_read_only_keys(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Lists the read-only access keys for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "primaryReadonlyMasterKey": "str",  # Optional. Base 64 encoded value of the
                      primary read-only key.
                    "secondaryReadonlyMasterKey": "str"  # Optional. Base 64 encoded value of the
                      secondary read-only key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_database_accounts_list_read_only_keys_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _regenerate_key_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, key_to_regenerate: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(key_to_regenerate, (IO, bytes)):
            _content = key_to_regenerate
        else:
            _json = key_to_regenerate

        request = build_database_accounts_regenerate_key_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def begin_regenerate_key(
        self,
        resource_group_name: str,
        account_name: str,
        key_to_regenerate: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Regenerates an access key for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param key_to_regenerate: The name of the key to regenerate. Required.
        :type key_to_regenerate: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                key_to_regenerate = {
                    "keyKind": "str"  # The access key to regenerate. Required. Known values are:
                      "primary", "secondary", "primaryReadonly", and "secondaryReadonly".
                }
        """

    @overload
    async def begin_regenerate_key(
        self,
        resource_group_name: str,
        account_name: str,
        key_to_regenerate: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Regenerates an access key for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param key_to_regenerate: The name of the key to regenerate. Required.
        :type key_to_regenerate: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_regenerate_key(
        self, resource_group_name: str, account_name: str, key_to_regenerate: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Regenerates an access key for the specified Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param key_to_regenerate: The name of the key to regenerate. Is either a model type or a IO
         type. Required.
        :type key_to_regenerate: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._regenerate_key_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                key_to_regenerate=key_to_regenerate,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def check_name_exists(self, account_name: str, **kwargs: Any) -> bool:
        """Checks that the Azure Cosmos DB account name already exists. A valid account name may contain
        only lowercase letters, numbers, and the '-' character, and must be between 3 and 50
        characters.

        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_database_accounts_check_name_exists_request(
            account_name=account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    @distributed_trace
    def list_metrics(
        self, resource_group_name: str, account_name: str, *, filter: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_accounts_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_usages(
        self, resource_group_name: str, account_name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the usages (most recent data) for the given database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword filter: An OData filter expression that describes a subset of usages to return. The
         supported parameter is name.value (name of the metric, can have an or of multiple names).
         Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "currentValue": 0,  # Optional. Current value for this metric.
                    "limit": 0,  # Optional. Maximum value for this metric.
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "quotaPeriod": "str",  # Optional. The quota period used to summarize the
                      usage values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_accounts_list_usages_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_metric_definitions(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves metric definitions for the given database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "metricAvailabilities": [
                        {
                            "retention": "str",  # Optional. The retention for the metric
                              values.
                            "timeGrain": "str"  # Optional. The time grain to be used to
                              summarize the metric values.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "primaryAggregationType": "str",  # Optional. The primary aggregation type of
                      the metric. Known values are: "None", "Average", "Total", "Minimum", "Maximum",
                      and "Last".
                    "resourceUri": "str",  # Optional. The resource uri of the database.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_accounts_list_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists all of the available Cosmos DB Resource Provider operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "Description": "str",  # Optional. Description of operation.
                        "Operation": "str",  # Optional. Operation type: Read, write, delete,
                          etc.
                        "Provider": "str",  # Optional. Service provider:
                          Microsoft.ResourceProvider.
                        "Resource": "str"  # Optional. Resource on which the operation is
                          performed: Profile, endpoint, etc.
                    },
                    "name": "str"  # Optional. Operation name: {provider}/{resource}/{operation}.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DatabaseOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`database` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self, resource_group_name: str, account_name: str, database_rid: str, *, filter: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given database account and
        database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_usages(
        self,
        resource_group_name: str,
        account_name: str,
        database_rid: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the usages (most recent data) for the given database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :keyword filter: An OData filter expression that describes a subset of usages to return. The
         supported parameter is name.value (name of the metric, can have an or of multiple names).
         Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "currentValue": 0,  # Optional. Current value for this metric.
                    "limit": 0,  # Optional. Maximum value for this metric.
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "quotaPeriod": "str",  # Optional. The quota period used to summarize the
                      usage values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_list_usages_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_metric_definitions(
        self, resource_group_name: str, account_name: str, database_rid: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves metric definitions for the given database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "metricAvailabilities": [
                        {
                            "retention": "str",  # Optional. The retention for the metric
                              values.
                            "timeGrain": "str"  # Optional. The time grain to be used to
                              summarize the metric values.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "primaryAggregationType": "str",  # Optional. The primary aggregation type of
                      the metric. Known values are: "None", "Average", "Total", "Minimum", "Maximum",
                      and "Last".
                    "resourceUri": "str",  # Optional. The resource uri of the database.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_list_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class CollectionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`collection` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        database_rid: str,
        collection_rid: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given database account and
        collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_usages(
        self,
        resource_group_name: str,
        account_name: str,
        database_rid: str,
        collection_rid: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the usages (most recent storage data) for the given collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :keyword filter: An OData filter expression that describes a subset of usages to return. The
         supported parameter is name.value (name of the metric, can have an or of multiple names).
         Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "currentValue": 0,  # Optional. Current value for this metric.
                    "limit": 0,  # Optional. Maximum value for this metric.
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "quotaPeriod": "str",  # Optional. The quota period used to summarize the
                      usage values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_list_usages_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_metric_definitions(
        self, resource_group_name: str, account_name: str, database_rid: str, collection_rid: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves metric definitions for the given collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "metricAvailabilities": [
                        {
                            "retention": "str",  # Optional. The retention for the metric
                              values.
                            "timeGrain": "str"  # Optional. The time grain to be used to
                              summarize the metric values.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "primaryAggregationType": "str",  # Optional. The primary aggregation type of
                      the metric. Known values are: "None", "Average", "Total", "Minimum", "Maximum",
                      and "Last".
                    "resourceUri": "str",  # Optional. The resource uri of the database.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_list_metric_definitions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class CollectionRegionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`collection_region` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        region: str,
        database_rid: str,
        collection_rid: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given database account, collection
        and region.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region: Cosmos DB region, with spaces between words and each word capitalized. Required.
        :type region: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_region_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    region=region,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DatabaseAccountRegionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`database_account_region` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self, resource_group_name: str, account_name: str, region: str, *, filter: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given database account and region.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region: Cosmos DB region, with spaces between words and each word capitalized. Required.
        :type region: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_database_account_region_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    region=region,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PercentileSourceTargetOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`percentile_source_target` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        source_region: str,
        target_region: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given account, source and target
        region. This url is only for PBS and Replication Latency data.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param source_region: Source region from which data is written. Cosmos DB region, with spaces
         between words and each word capitalized. Required.
        :type source_region: str
        :param target_region: Target region to which data is written. Cosmos DB region, with spaces
         between words and each word capitalized. Required.
        :type target_region: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "P10": 0.0,  # Optional. The 10th percentile value for the
                              metric.
                            "P25": 0.0,  # Optional. The 25th percentile value for the
                              metric.
                            "P50": 0.0,  # Optional. The 50th percentile value for the
                              metric.
                            "P75": 0.0,  # Optional. The 75th percentile value for the
                              metric.
                            "P90": 0.0,  # Optional. The 90th percentile value for the
                              metric.
                            "P95": 0.0,  # Optional. The 95th percentile value for the
                              metric.
                            "P99": 0.0,  # Optional. The 99th percentile value for the
                              metric.
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_percentile_source_target_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    source_region=source_region,
                    target_region=target_region,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PercentileTargetOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`percentile_target` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self, resource_group_name: str, account_name: str, target_region: str, *, filter: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given account target region. This
        url is only for PBS and Replication Latency data.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param target_region: Target region to which data is written. Cosmos DB region, with spaces
         between words and each word capitalized. Required.
        :type target_region: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "P10": 0.0,  # Optional. The 10th percentile value for the
                              metric.
                            "P25": 0.0,  # Optional. The 25th percentile value for the
                              metric.
                            "P50": 0.0,  # Optional. The 50th percentile value for the
                              metric.
                            "P75": 0.0,  # Optional. The 75th percentile value for the
                              metric.
                            "P90": 0.0,  # Optional. The 90th percentile value for the
                              metric.
                            "P95": 0.0,  # Optional. The 95th percentile value for the
                              metric.
                            "P99": 0.0,  # Optional. The 99th percentile value for the
                              metric.
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_percentile_target_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    target_region=target_region,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PercentileOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`percentile` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self, resource_group_name: str, account_name: str, *, filter: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given database account. This url
        is only for PBS and Replication Latency data.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "P10": 0.0,  # Optional. The 10th percentile value for the
                              metric.
                            "P25": 0.0,  # Optional. The 25th percentile value for the
                              metric.
                            "P50": 0.0,  # Optional. The 50th percentile value for the
                              metric.
                            "P75": 0.0,  # Optional. The 75th percentile value for the
                              metric.
                            "P90": 0.0,  # Optional. The 90th percentile value for the
                              metric.
                            "P95": 0.0,  # Optional. The 95th percentile value for the
                              metric.
                            "P99": 0.0,  # Optional. The 99th percentile value for the
                              metric.
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_percentile_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class CollectionPartitionRegionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`collection_partition_region` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        region: str,
        database_rid: str,
        collection_rid: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given collection and region, split
        by partition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region: Cosmos DB region, with spaces between words and each word capitalized. Required.
        :type region: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "partitionId": "str",  # Optional. The partition id (GUID identifier) of the
                      metric values.
                    "partitionKeyRangeId": "str",  # Optional. The partition key range id
                      (integer identifier) of the metric values.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_partition_region_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    region=region,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class CollectionPartitionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`collection_partition` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        database_rid: str,
        collection_rid: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given collection, split by
        partition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "partitionId": "str",  # Optional. The partition id (GUID identifier) of the
                      metric values.
                    "partitionKeyRangeId": "str",  # Optional. The partition key range id
                      (integer identifier) of the metric values.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_partition_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_usages(
        self,
        resource_group_name: str,
        account_name: str,
        database_rid: str,
        collection_rid: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the usages (most recent storage data) for the given collection, split by partition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :keyword filter: An OData filter expression that describes a subset of usages to return. The
         supported parameter is name.value (name of the metric, can have an or of multiple names).
         Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "currentValue": 0,  # Optional. Current value for this metric.
                    "limit": 0,  # Optional. Maximum value for this metric.
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "partitionId": "str",  # Optional. The partition id (GUID identifier) of the
                      usages.
                    "partitionKeyRangeId": "str",  # Optional. The partition key range id
                      (integer identifier) of the usages.
                    "quotaPeriod": "str",  # Optional. The quota period used to summarize the
                      usage values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_collection_partition_list_usages_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PartitionKeyRangeIdOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`partition_key_range_id` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        database_rid: str,
        collection_rid: str,
        partition_key_range_id: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given partition key range id.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :param partition_key_range_id: Partition Key Range Id for which to get data. Required.
        :type partition_key_range_id: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "partitionId": "str",  # Optional. The partition id (GUID identifier) of the
                      metric values.
                    "partitionKeyRangeId": "str",  # Optional. The partition key range id
                      (integer identifier) of the metric values.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_partition_key_range_id_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    partition_key_range_id=partition_key_range_id,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PartitionKeyRangeIdRegionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`partition_key_range_id_region` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_metrics(
        self,
        resource_group_name: str,
        account_name: str,
        region: str,
        database_rid: str,
        collection_rid: str,
        partition_key_range_id: str,
        *,
        filter: str,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the metrics determined by the given filter for the given partition key range id and
        region.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param region: Cosmos DB region, with spaces between words and each word capitalized. Required.
        :type region: str
        :param database_rid: Cosmos DB database rid. Required.
        :type database_rid: str
        :param collection_rid: Cosmos DB collection rid. Required.
        :type collection_rid: str
        :param partition_key_range_id: Partition Key Range Id for which to get data. Required.
        :type partition_key_range_id: str
        :keyword filter: An OData filter expression that describes a subset of metrics to return. The
         parameters that can be filtered are name.value (name of the metric, can have an or of multiple
         names), startTime, endTime, and timeGrain. The supported operator is eq. Required.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time for the metric
                      (ISO-8601 format).
                    "metricValues": [
                        {
                            "_count": 0,  # Optional. The number of values for the
                              metric.
                            "average": 0.0,  # Optional. The average value of the metric.
                            "maximum": 0.0,  # Optional. The max value of the metric.
                            "minimum": 0.0,  # Optional. The min value of the metric.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The metric
                              timestamp (ISO-8601 format).
                            "total": 0.0  # Optional. The total value of the metric.
                        }
                    ],
                    "name": {
                        "localizedValue": "str",  # Optional. The friendly name of the
                          metric.
                        "value": "str"  # Optional. The name of the metric.
                    },
                    "partitionId": "str",  # Optional. The partition id (GUID identifier) of the
                      metric values.
                    "partitionKeyRangeId": "str",  # Optional. The partition key range id
                      (integer identifier) of the metric values.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time for the
                      metric (ISO-8601 format).
                    "timeGrain": "str",  # Optional. The time grain to be used to summarize the
                      metric values.
                    "unit": "str"  # Optional. The unit of the metric. Known values are: "Count",
                      "Bytes", "Seconds", "Percent", "CountPerSecond", "BytesPerSecond", and
                      "Milliseconds".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_partition_key_range_id_region_list_metrics_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    region=region,
                    database_rid=database_rid,
                    collection_rid=collection_rid,
                    partition_key_range_id=partition_key_range_id,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class GraphResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`graph_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_graphs(self, resource_group_name: str, account_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists the graphs under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Graph. Required.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_graph_resources_list_graphs_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_graph(self, resource_group_name: str, account_name: str, graph_name: str, **kwargs: Any) -> JSON:
        """Gets the Graph resource under an existing Azure Cosmos DB database account with the provided
        name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param graph_name: Cosmos DB graph resource name. Required.
        :type graph_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Graph. Required.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_graph_resources_get_graph_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_graph_initial(
        self,
        resource_group_name: str,
        account_name: str,
        graph_name: str,
        create_update_graph_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_graph_parameters, (IO, bytes)):
            _content = create_update_graph_parameters
        else:
            _json = create_update_graph_parameters

        request = build_graph_resources_create_update_graph_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_graph(
        self,
        resource_group_name: str,
        account_name: str,
        graph_name: str,
        create_update_graph_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param graph_name: Cosmos DB graph resource name. Required.
        :type graph_name: str
        :param create_update_graph_parameters: The parameters to provide for the current graph.
         Required.
        :type create_update_graph_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_graph_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Graph. Required.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Graph. Required.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_graph(
        self,
        resource_group_name: str,
        account_name: str,
        graph_name: str,
        create_update_graph_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param graph_name: Cosmos DB graph resource name. Required.
        :type graph_name: str
        :param create_update_graph_parameters: The parameters to provide for the current graph.
         Required.
        :type create_update_graph_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Graph. Required.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_graph(
        self,
        resource_group_name: str,
        account_name: str,
        graph_name: str,
        create_update_graph_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param graph_name: Cosmos DB graph resource name. Required.
        :type graph_name: str
        :param create_update_graph_parameters: The parameters to provide for the current graph. Is
         either a model type or a IO type. Required.
        :type create_update_graph_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Graph. Required.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_graph_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                graph_name=graph_name,
                create_update_graph_parameters=create_update_graph_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_graph_resource_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, graph_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_graph_resources_delete_graph_resource_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_graph_resource(
        self, resource_group_name: str, account_name: str, graph_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Graph Resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param graph_name: Cosmos DB graph resource name. Required.
        :type graph_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_graph_resource_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                graph_name=graph_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class SqlResourcesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`sql_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_sql_databases(self, resource_group_name: str, account_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists the SQL databases under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL database. Required.
                            "_colls": "str",  # Optional. A system generated property
                              that specified the addressable path of the collections resource.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "_users": "str",  # Optional. A system generated property
                              that specifies the addressable path of the users resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_databases_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_sql_database(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the SQL database under an existing Azure Cosmos DB database account with the provided
        name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL database. Required.
                            "_colls": "str",  # Optional. A system generated property
                              that specified the addressable path of the collections resource.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "_users": "str",  # Optional. A system generated property
                              that specifies the addressable path of the users resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_database_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_sql_database_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_database_parameters, (IO, bytes)):
            _content = create_update_sql_database_parameters
        else:
            _json = create_update_sql_database_parameters

        request = build_sql_resources_create_update_sql_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_sql_database_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_sql_database_parameters: The parameters to provide for the current SQL
         database. Required.
        :type create_update_sql_database_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_database_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL database. Required.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL database. Required.
                            "_colls": "str",  # Optional. A system generated property
                              that specified the addressable path of the collections resource.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "_users": "str",  # Optional. A system generated property
                              that specifies the addressable path of the users resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_sql_database_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_sql_database_parameters: The parameters to provide for the current SQL
         database. Required.
        :type create_update_sql_database_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL database. Required.
                            "_colls": "str",  # Optional. A system generated property
                              that specified the addressable path of the collections resource.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "_users": "str",  # Optional. A system generated property
                              that specifies the addressable path of the users resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_sql_database_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_sql_database_parameters: The parameters to provide for the current SQL
         database. Is either a model type or a IO type. Required.
        :type create_update_sql_database_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL database. Required.
                            "_colls": "str",  # Optional. A system generated property
                              that specified the addressable path of the collections resource.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "_users": "str",  # Optional. A system generated property
                              that specifies the addressable path of the users resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_database_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                create_update_sql_database_parameters=create_update_sql_database_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_database_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_database(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_database_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_sql_database_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the SQL database under an existing Azure Cosmos DB database account
        with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_database_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_sql_database_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_sql_resources_update_sql_database_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_sql_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current SQL database. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_sql_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current SQL database. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_sql_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current SQL database. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_sql_database_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_sql_database_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_sql_resources_migrate_sql_database_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_sql_database_to_autoscale(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_sql_database_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_sql_database_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_sql_resources_migrate_sql_database_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_sql_database_to_manual_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_sql_database_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_client_encryption_keys(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "encryptionAlgorithm": "str",  # Optional. Encryption
                              algorithm that will be used along with this client encryption key to
                              encrypt/decrypt data.
                            "id": "str",  # Optional. Name of the ClientEncryptionKey.
                            "keyWrapMetadata": {
                                "algorithm": "str",  # Optional. Algorithm used in
                                  wrapping and unwrapping of the data encryption key.
                                "name": "str",  # Optional. The name of associated
                                  KeyEncryptionKey (aka CustomerManagedKey).
                                "type": "str",  # Optional. ProviderName of
                                  KeyStoreProvider.
                                "value": "str"  # Optional. Reference / link to the
                                  KeyEncryptionKey.
                            },
                            "wrappedDataEncryptionKey": bytes("bytes", encoding="utf-8")
                              # Optional. Wrapped (encrypted) form of the key represented as a byte
                              array.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_client_encryption_keys_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_client_encryption_key(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        client_encryption_key_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the ClientEncryptionKey under an existing Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param client_encryption_key_name: Cosmos DB ClientEncryptionKey name. Required.
        :type client_encryption_key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "encryptionAlgorithm": "str",  # Optional. Encryption
                              algorithm that will be used along with this client encryption key to
                              encrypt/decrypt data.
                            "id": "str",  # Optional. Name of the ClientEncryptionKey.
                            "keyWrapMetadata": {
                                "algorithm": "str",  # Optional. Algorithm used in
                                  wrapping and unwrapping of the data encryption key.
                                "name": "str",  # Optional. The name of associated
                                  KeyEncryptionKey (aka CustomerManagedKey).
                                "type": "str",  # Optional. ProviderName of
                                  KeyStoreProvider.
                                "value": "str"  # Optional. Reference / link to the
                                  KeyEncryptionKey.
                            },
                            "wrappedDataEncryptionKey": bytes("bytes", encoding="utf-8")
                              # Optional. Wrapped (encrypted) form of the key represented as a byte
                              array.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_client_encryption_key_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            client_encryption_key_name=client_encryption_key_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_client_encryption_key_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        client_encryption_key_name: str,
        create_update_client_encryption_key_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_client_encryption_key_parameters, (IO, bytes)):
            _content = create_update_client_encryption_key_parameters
        else:
            _json = create_update_client_encryption_key_parameters

        request = build_sql_resources_create_update_client_encryption_key_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            client_encryption_key_name=client_encryption_key_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_client_encryption_key(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        client_encryption_key_name: str,
        create_update_client_encryption_key_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the
        Azure Powershell (instead of directly).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param client_encryption_key_name: Cosmos DB ClientEncryptionKey name. Required.
        :type client_encryption_key_name: str
        :param create_update_client_encryption_key_parameters: The parameters to provide for the client
         encryption key. Required.
        :type create_update_client_encryption_key_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_client_encryption_key_parameters = {
                    "properties": {
                        "resource": {
                            "encryptionAlgorithm": "str",  # Optional. Encryption
                              algorithm that will be used along with this client encryption key to
                              encrypt/decrypt data.
                            "id": "str",  # Optional. Name of the ClientEncryptionKey.
                            "keyWrapMetadata": {
                                "algorithm": "str",  # Optional. Algorithm used in
                                  wrapping and unwrapping of the data encryption key.
                                "name": "str",  # Optional. The name of associated
                                  KeyEncryptionKey (aka CustomerManagedKey).
                                "type": "str",  # Optional. ProviderName of
                                  KeyStoreProvider.
                                "value": "str"  # Optional. Reference / link to the
                                  KeyEncryptionKey.
                            },
                            "wrappedDataEncryptionKey": bytes("bytes", encoding="utf-8")
                              # Optional. Wrapped (encrypted) form of the key represented as a byte
                              array.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "encryptionAlgorithm": "str",  # Optional. Encryption
                              algorithm that will be used along with this client encryption key to
                              encrypt/decrypt data.
                            "id": "str",  # Optional. Name of the ClientEncryptionKey.
                            "keyWrapMetadata": {
                                "algorithm": "str",  # Optional. Algorithm used in
                                  wrapping and unwrapping of the data encryption key.
                                "name": "str",  # Optional. The name of associated
                                  KeyEncryptionKey (aka CustomerManagedKey).
                                "type": "str",  # Optional. ProviderName of
                                  KeyStoreProvider.
                                "value": "str"  # Optional. Reference / link to the
                                  KeyEncryptionKey.
                            },
                            "wrappedDataEncryptionKey": bytes("bytes", encoding="utf-8")
                              # Optional. Wrapped (encrypted) form of the key represented as a byte
                              array.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_client_encryption_key(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        client_encryption_key_name: str,
        create_update_client_encryption_key_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the
        Azure Powershell (instead of directly).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param client_encryption_key_name: Cosmos DB ClientEncryptionKey name. Required.
        :type client_encryption_key_name: str
        :param create_update_client_encryption_key_parameters: The parameters to provide for the client
         encryption key. Required.
        :type create_update_client_encryption_key_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "encryptionAlgorithm": "str",  # Optional. Encryption
                              algorithm that will be used along with this client encryption key to
                              encrypt/decrypt data.
                            "id": "str",  # Optional. Name of the ClientEncryptionKey.
                            "keyWrapMetadata": {
                                "algorithm": "str",  # Optional. Algorithm used in
                                  wrapping and unwrapping of the data encryption key.
                                "name": "str",  # Optional. The name of associated
                                  KeyEncryptionKey (aka CustomerManagedKey).
                                "type": "str",  # Optional. ProviderName of
                                  KeyStoreProvider.
                                "value": "str"  # Optional. Reference / link to the
                                  KeyEncryptionKey.
                            },
                            "wrappedDataEncryptionKey": bytes("bytes", encoding="utf-8")
                              # Optional. Wrapped (encrypted) form of the key represented as a byte
                              array.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_client_encryption_key(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        client_encryption_key_name: str,
        create_update_client_encryption_key_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the
        Azure Powershell (instead of directly).

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param client_encryption_key_name: Cosmos DB ClientEncryptionKey name. Required.
        :type client_encryption_key_name: str
        :param create_update_client_encryption_key_parameters: The parameters to provide for the client
         encryption key. Is either a model type or a IO type. Required.
        :type create_update_client_encryption_key_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "encryptionAlgorithm": "str",  # Optional. Encryption
                              algorithm that will be used along with this client encryption key to
                              encrypt/decrypt data.
                            "id": "str",  # Optional. Name of the ClientEncryptionKey.
                            "keyWrapMetadata": {
                                "algorithm": "str",  # Optional. Algorithm used in
                                  wrapping and unwrapping of the data encryption key.
                                "name": "str",  # Optional. The name of associated
                                  KeyEncryptionKey (aka CustomerManagedKey).
                                "type": "str",  # Optional. ProviderName of
                                  KeyStoreProvider.
                                "value": "str"  # Optional. Reference / link to the
                                  KeyEncryptionKey.
                            },
                            "wrappedDataEncryptionKey": bytes("bytes", encoding="utf-8")
                              # Optional. Wrapped (encrypted) form of the key represented as a byte
                              array.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_client_encryption_key_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                client_encryption_key_name=client_encryption_key_name,
                create_update_client_encryption_key_parameters=create_update_client_encryption_key_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_sql_containers(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the SQL container under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL container.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "clientEncryptionPolicy": {
                                "includedPaths": [
                                    {
                                        "clientEncryptionKeyId": "str",  #
                                          The identifier of the Client Encryption Key to be used to
                                          encrypt the path. Required.
                                        "encryptionAlgorithm": "str",  # The
                                          encryption algorithm which will be used. Eg -
                                          AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                        "encryptionType": "str",  # The type
                                          of encryption to be performed. Eg - Deterministic,
                                          Randomized. Required.
                                        "path": "str"  # Path that needs to
                                          be encrypted. Required.
                                    }
                                ],
                                "policyFormatVersion": 1  # Optional. Default value
                                  is 1. Version of the client encryption policy definition. Please
                                  note, user passed value is ignored. Default policy version is 1.
                            },
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_containers_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_sql_container(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the SQL container under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL container.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "clientEncryptionPolicy": {
                                "includedPaths": [
                                    {
                                        "clientEncryptionKeyId": "str",  #
                                          The identifier of the Client Encryption Key to be used to
                                          encrypt the path. Required.
                                        "encryptionAlgorithm": "str",  # The
                                          encryption algorithm which will be used. Eg -
                                          AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                        "encryptionType": "str",  # The type
                                          of encryption to be performed. Eg - Deterministic,
                                          Randomized. Required.
                                        "path": "str"  # Path that needs to
                                          be encrypted. Required.
                                    }
                                ],
                                "policyFormatVersion": 1  # Optional. Default value
                                  is 1. Version of the client encryption policy definition. Please
                                  note, user passed value is ignored. Default policy version is 1.
                            },
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_container_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_container_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        create_update_sql_container_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_container_parameters, (IO, bytes)):
            _content = create_update_sql_container_parameters
        else:
            _json = create_update_sql_container_parameters

        request = build_sql_resources_create_update_sql_container_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_container(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        create_update_sql_container_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param create_update_sql_container_parameters: The parameters to provide for the current SQL
         container. Required.
        :type create_update_sql_container_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_container_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL container.
                              Required.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "clientEncryptionPolicy": {
                                "includedPaths": [
                                    {
                                        "clientEncryptionKeyId": "str",  #
                                          The identifier of the Client Encryption Key to be used to
                                          encrypt the path. Required.
                                        "encryptionAlgorithm": "str",  # The
                                          encryption algorithm which will be used. Eg -
                                          AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                        "encryptionType": "str",  # The type
                                          of encryption to be performed. Eg - Deterministic,
                                          Randomized. Required.
                                        "path": "str"  # Path that needs to
                                          be encrypted. Required.
                                    }
                                ],
                                "policyFormatVersion": 1  # Optional. Default value
                                  is 1. Version of the client encryption policy definition. Please
                                  note, user passed value is ignored. Default policy version is 1.
                            },
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL container.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "clientEncryptionPolicy": {
                                "includedPaths": [
                                    {
                                        "clientEncryptionKeyId": "str",  #
                                          The identifier of the Client Encryption Key to be used to
                                          encrypt the path. Required.
                                        "encryptionAlgorithm": "str",  # The
                                          encryption algorithm which will be used. Eg -
                                          AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                        "encryptionType": "str",  # The type
                                          of encryption to be performed. Eg - Deterministic,
                                          Randomized. Required.
                                        "path": "str"  # Path that needs to
                                          be encrypted. Required.
                                    }
                                ],
                                "policyFormatVersion": 1  # Optional. Default value
                                  is 1. Version of the client encryption policy definition. Please
                                  note, user passed value is ignored. Default policy version is 1.
                            },
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_container(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        create_update_sql_container_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param create_update_sql_container_parameters: The parameters to provide for the current SQL
         container. Required.
        :type create_update_sql_container_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL container.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "clientEncryptionPolicy": {
                                "includedPaths": [
                                    {
                                        "clientEncryptionKeyId": "str",  #
                                          The identifier of the Client Encryption Key to be used to
                                          encrypt the path. Required.
                                        "encryptionAlgorithm": "str",  # The
                                          encryption algorithm which will be used. Eg -
                                          AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                        "encryptionType": "str",  # The type
                                          of encryption to be performed. Eg - Deterministic,
                                          Randomized. Required.
                                        "path": "str"  # Path that needs to
                                          be encrypted. Required.
                                    }
                                ],
                                "policyFormatVersion": 1  # Optional. Default value
                                  is 1. Version of the client encryption policy definition. Please
                                  note, user passed value is ignored. Default policy version is 1.
                            },
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_container(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        create_update_sql_container_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param create_update_sql_container_parameters: The parameters to provide for the current SQL
         container. Is either a model type or a IO type. Required.
        :type create_update_sql_container_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL container.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "clientEncryptionPolicy": {
                                "includedPaths": [
                                    {
                                        "clientEncryptionKeyId": "str",  #
                                          The identifier of the Client Encryption Key to be used to
                                          encrypt the path. Required.
                                        "encryptionAlgorithm": "str",  # The
                                          encryption algorithm which will be used. Eg -
                                          AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                        "encryptionType": "str",  # The type
                                          of encryption to be performed. Eg - Deterministic,
                                          Randomized. Required.
                                        "path": "str"  # Path that needs to
                                          be encrypted. Required.
                                    }
                                ],
                                "policyFormatVersion": 1  # Optional. Default value
                                  is 1. Version of the client encryption policy definition. Please
                                  note, user passed value is ignored. Default policy version is 1.
                            },
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_container_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                create_update_sql_container_parameters=create_update_sql_container_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_container_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_container_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_container(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_container_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _list_sql_container_partition_merge_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        merge_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(merge_parameters, (IO, bytes)):
            _content = merge_parameters
        else:
            _json = merge_parameters

        request = build_sql_resources_list_sql_container_partition_merge_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_list_sql_container_partition_merge(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        merge_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Merges the partitions of a SQL Container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param merge_parameters: The parameters for the merge operation. Required.
        :type merge_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                merge_parameters = {
                    "isDryRun": bool  # Optional. Specifies whether the operation is a real merge
                      operation or a simulation.
                }

                # response body for status code(s): 200
                response == {
                    "physicalPartitionStorageInfoCollection": [
                        {
                            "id": "str",  # Optional. The unique identifier of the
                              partition.
                            "storageInKB": 0.0  # Optional. The storage in KB for the
                              physical partition.
                        }
                    ]
                }
        """

    @overload
    async def begin_list_sql_container_partition_merge(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        merge_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Merges the partitions of a SQL Container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param merge_parameters: The parameters for the merge operation. Required.
        :type merge_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "physicalPartitionStorageInfoCollection": [
                        {
                            "id": "str",  # Optional. The unique identifier of the
                              partition.
                            "storageInKB": 0.0  # Optional. The storage in KB for the
                              physical partition.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def begin_list_sql_container_partition_merge(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        merge_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Merges the partitions of a SQL Container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param merge_parameters: The parameters for the merge operation. Is either a model type or a IO
         type. Required.
        :type merge_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "physicalPartitionStorageInfoCollection": [
                        {
                            "id": "str",  # Optional. The unique identifier of the
                              partition.
                            "storageInKB": 0.0  # Optional. The storage in KB for the
                              physical partition.
                        }
                    ]
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._list_sql_container_partition_merge_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                merge_parameters=merge_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_sql_container_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the SQL container under an existing Azure Cosmos DB database
        account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_container_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_sql_container_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_sql_resources_update_sql_container_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_sql_container_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current SQL container. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_sql_container_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current SQL container. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_sql_container_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current SQL container. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_sql_container_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_sql_container_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_sql_resources_migrate_sql_container_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_sql_container_to_autoscale(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_sql_container_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_sql_container_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_sql_resources_migrate_sql_container_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_sql_container_to_manual_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_sql_container_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _sql_database_retrieve_throughput_distribution_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(retrieve_throughput_parameters, (IO, bytes)):
            _content = retrieve_throughput_parameters
        else:
            _json = retrieve_throughput_parameters

        request = build_sql_resources_sql_database_retrieve_throughput_distribution_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_sql_database_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current SQL database. Required.
        :type retrieve_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                retrieve_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "physicalPartitionIds": [
                                {
                                    "id": "str"  # Id of a physical partition.
                                      Required.
                                }
                            ]
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_sql_database_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current SQL database. Required.
        :type retrieve_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_sql_database_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current SQL database. Is either a model type or a IO type. Required.
        :type retrieve_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._sql_database_retrieve_throughput_distribution_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                retrieve_throughput_parameters=retrieve_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _sql_database_redistribute_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(redistribute_throughput_parameters, (IO, bytes)):
            _content = redistribute_throughput_parameters
        else:
            _json = redistribute_throughput_parameters

        request = build_sql_resources_sql_database_redistribute_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_sql_database_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current SQL database. Required.
        :type redistribute_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                redistribute_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "sourcePhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "targetPhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "throughputPolicy": "str"  # ThroughputPolicy to apply for
                              throughput redistribution. Required. Known values are: "none", "equal",
                              and "custom".
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_sql_database_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current SQL database. Required.
        :type redistribute_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_sql_database_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB SQL database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current SQL database. Is either a model type or a IO type. Required.
        :type redistribute_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._sql_database_redistribute_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                redistribute_throughput_parameters=redistribute_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _sql_container_retrieve_throughput_distribution_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(retrieve_throughput_parameters, (IO, bytes)):
            _content = retrieve_throughput_parameters
        else:
            _json = retrieve_throughput_parameters

        request = build_sql_resources_sql_container_retrieve_throughput_distribution_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_sql_container_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        retrieve_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current SQL container. Required.
        :type retrieve_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                retrieve_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "physicalPartitionIds": [
                                {
                                    "id": "str"  # Id of a physical partition.
                                      Required.
                                }
                            ]
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_sql_container_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        retrieve_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current SQL container. Required.
        :type retrieve_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_sql_container_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current SQL container. Is either a model type or a IO type. Required.
        :type retrieve_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._sql_container_retrieve_throughput_distribution_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                retrieve_throughput_parameters=retrieve_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _sql_container_redistribute_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(redistribute_throughput_parameters, (IO, bytes)):
            _content = redistribute_throughput_parameters
        else:
            _json = redistribute_throughput_parameters

        request = build_sql_resources_sql_container_redistribute_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_sql_container_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        redistribute_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current SQL container. Required.
        :type redistribute_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                redistribute_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "sourcePhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "targetPhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "throughputPolicy": "str"  # ThroughputPolicy to apply for
                              throughput redistribution. Required. Known values are: "none", "equal",
                              and "custom".
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_sql_container_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        redistribute_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current SQL container. Required.
        :type redistribute_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_sql_container_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB SQL container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current SQL container. Is either a model type or a IO type. Required.
        :type redistribute_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._sql_container_redistribute_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                redistribute_throughput_parameters=redistribute_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_sql_stored_procedures(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL storedProcedure.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the Stored Procedure.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_stored_procedures_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    container_name=container_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_sql_stored_procedure(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the SQL storedProcedure under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param stored_procedure_name: Cosmos DB storedProcedure name. Required.
        :type stored_procedure_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL storedProcedure.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the Stored Procedure.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_stored_procedure_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            stored_procedure_name=stored_procedure_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_stored_procedure_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        create_update_sql_stored_procedure_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_stored_procedure_parameters, (IO, bytes)):
            _content = create_update_sql_stored_procedure_parameters
        else:
            _json = create_update_sql_stored_procedure_parameters

        request = build_sql_resources_create_update_sql_stored_procedure_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            stored_procedure_name=stored_procedure_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_stored_procedure(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        create_update_sql_stored_procedure_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL storedProcedure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param stored_procedure_name: Cosmos DB storedProcedure name. Required.
        :type stored_procedure_name: str
        :param create_update_sql_stored_procedure_parameters: The parameters to provide for the current
         SQL storedProcedure. Required.
        :type create_update_sql_stored_procedure_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_stored_procedure_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL storedProcedure.
                              Required.
                            "body": "str"  # Optional. Body of the Stored Procedure.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL storedProcedure.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the Stored Procedure.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_stored_procedure(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        create_update_sql_stored_procedure_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL storedProcedure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param stored_procedure_name: Cosmos DB storedProcedure name. Required.
        :type stored_procedure_name: str
        :param create_update_sql_stored_procedure_parameters: The parameters to provide for the current
         SQL storedProcedure. Required.
        :type create_update_sql_stored_procedure_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL storedProcedure.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the Stored Procedure.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_stored_procedure(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        create_update_sql_stored_procedure_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL storedProcedure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param stored_procedure_name: Cosmos DB storedProcedure name. Required.
        :type stored_procedure_name: str
        :param create_update_sql_stored_procedure_parameters: The parameters to provide for the current
         SQL storedProcedure. Is either a model type or a IO type. Required.
        :type create_update_sql_stored_procedure_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL storedProcedure.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the Stored Procedure.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_stored_procedure_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                stored_procedure_name=stored_procedure_name,
                create_update_sql_stored_procedure_parameters=create_update_sql_stored_procedure_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_stored_procedure_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_stored_procedure_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            stored_procedure_name=stored_procedure_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_stored_procedure(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        stored_procedure_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL storedProcedure.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param stored_procedure_name: Cosmos DB storedProcedure name. Required.
        :type stored_procedure_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_stored_procedure_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                stored_procedure_name=stored_procedure_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_sql_user_defined_functions(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL
                              userDefinedFunction. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the User Defined Function.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_user_defined_functions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    container_name=container_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_sql_user_defined_function(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the SQL userDefinedFunction under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param user_defined_function_name: Cosmos DB userDefinedFunction name. Required.
        :type user_defined_function_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL
                              userDefinedFunction. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the User Defined Function.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_user_defined_function_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            user_defined_function_name=user_defined_function_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_user_defined_function_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        create_update_sql_user_defined_function_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_user_defined_function_parameters, (IO, bytes)):
            _content = create_update_sql_user_defined_function_parameters
        else:
            _json = create_update_sql_user_defined_function_parameters

        request = build_sql_resources_create_update_sql_user_defined_function_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            user_defined_function_name=user_defined_function_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_user_defined_function(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        create_update_sql_user_defined_function_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL userDefinedFunction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param user_defined_function_name: Cosmos DB userDefinedFunction name. Required.
        :type user_defined_function_name: str
        :param create_update_sql_user_defined_function_parameters: The parameters to provide for the
         current SQL userDefinedFunction. Required.
        :type create_update_sql_user_defined_function_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_user_defined_function_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL
                              userDefinedFunction. Required.
                            "body": "str"  # Optional. Body of the User Defined Function.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL
                              userDefinedFunction. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the User Defined Function.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_user_defined_function(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        create_update_sql_user_defined_function_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL userDefinedFunction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param user_defined_function_name: Cosmos DB userDefinedFunction name. Required.
        :type user_defined_function_name: str
        :param create_update_sql_user_defined_function_parameters: The parameters to provide for the
         current SQL userDefinedFunction. Required.
        :type create_update_sql_user_defined_function_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL
                              userDefinedFunction. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the User Defined Function.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_user_defined_function(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        create_update_sql_user_defined_function_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL userDefinedFunction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param user_defined_function_name: Cosmos DB userDefinedFunction name. Required.
        :type user_defined_function_name: str
        :param create_update_sql_user_defined_function_parameters: The parameters to provide for the
         current SQL userDefinedFunction. Is either a model type or a IO type. Required.
        :type create_update_sql_user_defined_function_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL
                              userDefinedFunction. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str"  # Optional. Body of the User Defined Function.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_user_defined_function_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                user_defined_function_name=user_defined_function_name,
                create_update_sql_user_defined_function_parameters=create_update_sql_user_defined_function_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_user_defined_function_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_user_defined_function_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            user_defined_function_name=user_defined_function_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_user_defined_function(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        user_defined_function_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL userDefinedFunction.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param user_defined_function_name: Cosmos DB userDefinedFunction name. Required.
        :type user_defined_function_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_user_defined_function_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                user_defined_function_name=user_defined_function_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_sql_triggers(
        self, resource_group_name: str, account_name: str, database_name: str, container_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the SQL trigger under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL trigger. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str",  # Optional. Body of the Trigger.
                            "triggerOperation": "str",  # Optional. The operation the
                              trigger is associated with. Known values are: "All", "Create", "Update",
                              "Delete", and "Replace".
                            "triggerType": "str"  # Optional. Type of the Trigger. Known
                              values are: "Pre" and "Post".
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_triggers_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    container_name=container_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_sql_trigger(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the SQL trigger under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param trigger_name: Cosmos DB trigger name. Required.
        :type trigger_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL trigger. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str",  # Optional. Body of the Trigger.
                            "triggerOperation": "str",  # Optional. The operation the
                              trigger is associated with. Known values are: "All", "Create", "Update",
                              "Delete", and "Replace".
                            "triggerType": "str"  # Optional. Type of the Trigger. Known
                              values are: "Pre" and "Post".
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_trigger_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_trigger_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        create_update_sql_trigger_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_trigger_parameters, (IO, bytes)):
            _content = create_update_sql_trigger_parameters
        else:
            _json = create_update_sql_trigger_parameters

        request = build_sql_resources_create_update_sql_trigger_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_trigger(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        create_update_sql_trigger_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param trigger_name: Cosmos DB trigger name. Required.
        :type trigger_name: str
        :param create_update_sql_trigger_parameters: The parameters to provide for the current SQL
         trigger. Required.
        :type create_update_sql_trigger_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_trigger_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL trigger. Required.
                            "body": "str",  # Optional. Body of the Trigger.
                            "triggerOperation": "str",  # Optional. The operation the
                              trigger is associated with. Known values are: "All", "Create", "Update",
                              "Delete", and "Replace".
                            "triggerType": "str"  # Optional. Type of the Trigger. Known
                              values are: "Pre" and "Post".
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL trigger. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str",  # Optional. Body of the Trigger.
                            "triggerOperation": "str",  # Optional. The operation the
                              trigger is associated with. Known values are: "All", "Create", "Update",
                              "Delete", and "Replace".
                            "triggerType": "str"  # Optional. Type of the Trigger. Known
                              values are: "Pre" and "Post".
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_trigger(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        create_update_sql_trigger_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param trigger_name: Cosmos DB trigger name. Required.
        :type trigger_name: str
        :param create_update_sql_trigger_parameters: The parameters to provide for the current SQL
         trigger. Required.
        :type create_update_sql_trigger_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL trigger. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str",  # Optional. Body of the Trigger.
                            "triggerOperation": "str",  # Optional. The operation the
                              trigger is associated with. Known values are: "All", "Create", "Update",
                              "Delete", and "Replace".
                            "triggerType": "str"  # Optional. Type of the Trigger. Known
                              values are: "Pre" and "Post".
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_trigger(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        create_update_sql_trigger_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB SQL trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param trigger_name: Cosmos DB trigger name. Required.
        :type trigger_name: str
        :param create_update_sql_trigger_parameters: The parameters to provide for the current SQL
         trigger. Is either a model type or a IO type. Required.
        :type create_update_sql_trigger_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB SQL trigger. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "body": "str",  # Optional. Body of the Trigger.
                            "triggerOperation": "str",  # Optional. The operation the
                              trigger is associated with. Known values are: "All", "Create", "Update",
                              "Delete", and "Replace".
                            "triggerType": "str"  # Optional. Type of the Trigger. Known
                              values are: "Pre" and "Post".
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_trigger_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                trigger_name=trigger_name,
                create_update_sql_trigger_parameters=create_update_sql_trigger_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_trigger_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_trigger_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            trigger_name=trigger_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_trigger(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        trigger_name: str,
        **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL trigger.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param trigger_name: Cosmos DB trigger name. Required.
        :type trigger_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_trigger_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                trigger_name=trigger_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_sql_role_definition(
        self, role_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> JSON:
        """Retrieves the properties of an existing Azure Cosmos DB SQL Role Definition with the given Id.

        :param role_definition_id: The GUID for the Role Definition. Required.
        :type role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. A set of fully qualified Scopes at or
                              below which Role Assignments may be created using this Role Definition.
                              This will allow application of this Role Definition on the entire
                              database account or any underlying Database / Collection. Must have at
                              least one element. Scopes higher than Database account are not
                              enforceable as assignable Scopes. Note that resources referenced in
                              assignable Scopes need not exist.
                        ],
                        "permissions": [
                            {
                                "dataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are allowed.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are denied.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_role_definition_request(
            role_definition_id=role_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_role_definition_initial(
        self,
        role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_definition_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_role_definition_parameters, (IO, bytes)):
            _content = create_update_sql_role_definition_parameters
        else:
            _json = create_update_sql_role_definition_parameters

        request = build_sql_resources_create_update_sql_role_definition_request(
            role_definition_id=role_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_role_definition(
        self,
        role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_definition_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB SQL Role Definition.

        :param role_definition_id: The GUID for the Role Definition. Required.
        :type role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_sql_role_definition_parameters: The properties required to create or
         update a Role Definition. Required.
        :type create_update_sql_role_definition_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_role_definition_parameters = {
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. A set of fully qualified Scopes at or
                              below which Role Assignments may be created using this Role Definition.
                              This will allow application of this Role Definition on the entire
                              database account or any underlying Database / Collection. Must have at
                              least one element. Scopes higher than Database account are not
                              enforceable as assignable Scopes. Note that resources referenced in
                              assignable Scopes need not exist.
                        ],
                        "permissions": [
                            {
                                "dataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are allowed.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are denied.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. A set of fully qualified Scopes at or
                              below which Role Assignments may be created using this Role Definition.
                              This will allow application of this Role Definition on the entire
                              database account or any underlying Database / Collection. Must have at
                              least one element. Scopes higher than Database account are not
                              enforceable as assignable Scopes. Note that resources referenced in
                              assignable Scopes need not exist.
                        ],
                        "permissions": [
                            {
                                "dataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are allowed.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are denied.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_role_definition(
        self,
        role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_definition_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB SQL Role Definition.

        :param role_definition_id: The GUID for the Role Definition. Required.
        :type role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_sql_role_definition_parameters: The properties required to create or
         update a Role Definition. Required.
        :type create_update_sql_role_definition_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. A set of fully qualified Scopes at or
                              below which Role Assignments may be created using this Role Definition.
                              This will allow application of this Role Definition on the entire
                              database account or any underlying Database / Collection. Must have at
                              least one element. Scopes higher than Database account are not
                              enforceable as assignable Scopes. Note that resources referenced in
                              assignable Scopes need not exist.
                        ],
                        "permissions": [
                            {
                                "dataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are allowed.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are denied.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_role_definition(
        self,
        role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_definition_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB SQL Role Definition.

        :param role_definition_id: The GUID for the Role Definition. Required.
        :type role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_sql_role_definition_parameters: The properties required to create or
         update a Role Definition. Is either a model type or a IO type. Required.
        :type create_update_sql_role_definition_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. A set of fully qualified Scopes at or
                              below which Role Assignments may be created using this Role Definition.
                              This will allow application of this Role Definition on the entire
                              database account or any underlying Database / Collection. Must have at
                              least one element. Scopes higher than Database account are not
                              enforceable as assignable Scopes. Note that resources referenced in
                              assignable Scopes need not exist.
                        ],
                        "permissions": [
                            {
                                "dataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are allowed.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are denied.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_role_definition_initial(  # type: ignore
                role_definition_id=role_definition_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                create_update_sql_role_definition_parameters=create_update_sql_role_definition_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_role_definition_initial(  # pylint: disable=inconsistent-return-statements
        self, role_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_role_definition_request(
            role_definition_id=role_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_role_definition(
        self, role_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL Role Definition.

        :param role_definition_id: The GUID for the Role Definition. Required.
        :type role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_role_definition_initial(  # type: ignore
                role_definition_id=role_definition_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_sql_role_definitions(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the list of all Azure Cosmos DB SQL Role Definitions.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. A set of fully qualified Scopes at or
                              below which Role Assignments may be created using this Role Definition.
                              This will allow application of this Role Definition on the entire
                              database account or any underlying Database / Collection. Must have at
                              least one element. Scopes higher than Database account are not
                              enforceable as assignable Scopes. Note that resources referenced in
                              assignable Scopes need not exist.
                        ],
                        "permissions": [
                            {
                                "dataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are allowed.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. An array of data actions
                                      that are denied.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_role_definitions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_sql_role_assignment(
        self, role_assignment_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> JSON:
        """Retrieves the properties of an existing Azure Cosmos DB SQL Role Assignment with the given Id.

        :param role_assignment_id: The GUID for the Role Assignment. Required.
        :type role_assignment_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "principalId": "str",  # Optional. The unique identifier for the
                          associated AAD principal in the AAD graph to which access is being granted
                          through this Role Assignment. Tenant ID for the principal is inferred using
                          the tenant associated with the subscription.
                        "roleDefinitionId": "str",  # Optional. The unique identifier for the
                          associated Role Definition.
                        "scope": "str"  # Optional. The data plane resource path for which
                          access is being granted through this Role Assignment.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sql_resources_get_sql_role_assignment_request(
            role_assignment_id=role_assignment_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_sql_role_assignment_initial(
        self,
        role_assignment_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_assignment_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_sql_role_assignment_parameters, (IO, bytes)):
            _content = create_update_sql_role_assignment_parameters
        else:
            _json = create_update_sql_role_assignment_parameters

        request = build_sql_resources_create_update_sql_role_assignment_request(
            role_assignment_id=role_assignment_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_sql_role_assignment(
        self,
        role_assignment_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_assignment_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB SQL Role Assignment.

        :param role_assignment_id: The GUID for the Role Assignment. Required.
        :type role_assignment_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_sql_role_assignment_parameters: The properties required to create or
         update a Role Assignment. Required.
        :type create_update_sql_role_assignment_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_sql_role_assignment_parameters = {
                    "properties": {
                        "principalId": "str",  # Optional. The unique identifier for the
                          associated AAD principal in the AAD graph to which access is being granted
                          through this Role Assignment. Tenant ID for the principal is inferred using
                          the tenant associated with the subscription.
                        "roleDefinitionId": "str",  # Optional. The unique identifier for the
                          associated Role Definition.
                        "scope": "str"  # Optional. The data plane resource path for which
                          access is being granted through this Role Assignment.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "principalId": "str",  # Optional. The unique identifier for the
                          associated AAD principal in the AAD graph to which access is being granted
                          through this Role Assignment. Tenant ID for the principal is inferred using
                          the tenant associated with the subscription.
                        "roleDefinitionId": "str",  # Optional. The unique identifier for the
                          associated Role Definition.
                        "scope": "str"  # Optional. The data plane resource path for which
                          access is being granted through this Role Assignment.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_sql_role_assignment(
        self,
        role_assignment_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_assignment_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB SQL Role Assignment.

        :param role_assignment_id: The GUID for the Role Assignment. Required.
        :type role_assignment_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_sql_role_assignment_parameters: The properties required to create or
         update a Role Assignment. Required.
        :type create_update_sql_role_assignment_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "principalId": "str",  # Optional. The unique identifier for the
                          associated AAD principal in the AAD graph to which access is being granted
                          through this Role Assignment. Tenant ID for the principal is inferred using
                          the tenant associated with the subscription.
                        "roleDefinitionId": "str",  # Optional. The unique identifier for the
                          associated Role Definition.
                        "scope": "str"  # Optional. The data plane resource path for which
                          access is being granted through this Role Assignment.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_sql_role_assignment(
        self,
        role_assignment_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_sql_role_assignment_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB SQL Role Assignment.

        :param role_assignment_id: The GUID for the Role Assignment. Required.
        :type role_assignment_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_sql_role_assignment_parameters: The properties required to create or
         update a Role Assignment. Is either a model type or a IO type. Required.
        :type create_update_sql_role_assignment_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "principalId": "str",  # Optional. The unique identifier for the
                          associated AAD principal in the AAD graph to which access is being granted
                          through this Role Assignment. Tenant ID for the principal is inferred using
                          the tenant associated with the subscription.
                        "roleDefinitionId": "str",  # Optional. The unique identifier for the
                          associated Role Definition.
                        "scope": "str"  # Optional. The data plane resource path for which
                          access is being granted through this Role Assignment.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_sql_role_assignment_initial(  # type: ignore
                role_assignment_id=role_assignment_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                create_update_sql_role_assignment_parameters=create_update_sql_role_assignment_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_sql_role_assignment_initial(  # pylint: disable=inconsistent-return-statements
        self, role_assignment_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sql_resources_delete_sql_role_assignment_request(
            role_assignment_id=role_assignment_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_sql_role_assignment(
        self, role_assignment_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB SQL Role Assignment.

        :param role_assignment_id: The GUID for the Role Assignment. Required.
        :type role_assignment_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_sql_role_assignment_initial(  # type: ignore
                role_assignment_id=role_assignment_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_sql_role_assignments(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the list of all Azure Cosmos DB SQL Role Assignments.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "principalId": "str",  # Optional. The unique identifier for the
                          associated AAD principal in the AAD graph to which access is being granted
                          through this Role Assignment. Tenant ID for the principal is inferred using
                          the tenant associated with the subscription.
                        "roleDefinitionId": "str",  # Optional. The unique identifier for the
                          associated Role Definition.
                        "scope": "str"  # Optional. The data plane resource path for which
                          access is being granted through this Role Assignment.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sql_resources_list_sql_role_assignments_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _retrieve_continuous_backup_information_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        location: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(location, (IO, bytes)):
            _content = location
        else:
            _json = location

        request = build_sql_resources_retrieve_continuous_backup_information_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        location: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a container resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                location = {
                    "location": "str"  # Optional. The name of the continuous backup restore
                      location.
                }

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        location: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a container resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @distributed_trace_async
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        container_name: str,
        location: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a container resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param container_name: Cosmos DB container name. Required.
        :type container_name: str
        :param location: The name of the continuous backup restore location. Is either a model type or
         a IO type. Required.
        :type location: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._retrieve_continuous_backup_information_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                container_name=container_name,
                location=location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class MongoDBResourcesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`mongo_db_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_mongo_db_databases(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the MongoDB databases under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_mongo_db_resources_list_mongo_db_databases_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_mongo_db_database(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
        name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_mongo_db_resources_get_mongo_db_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_mongo_db_database_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_mongo_db_database_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_mongo_db_database_parameters, (IO, bytes)):
            _content = create_update_mongo_db_database_parameters
        else:
            _json = create_update_mongo_db_database_parameters

        request = build_mongo_db_resources_create_update_mongo_db_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_mongo_db_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_mongo_db_database_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or updates Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_mongo_db_database_parameters: The parameters to provide for the current
         MongoDB database. Required.
        :type create_update_mongo_db_database_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_mongo_db_database_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB database.
                              Required.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_mongo_db_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_mongo_db_database_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or updates Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_mongo_db_database_parameters: The parameters to provide for the current
         MongoDB database. Required.
        :type create_update_mongo_db_database_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_mongo_db_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_mongo_db_database_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or updates Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_mongo_db_database_parameters: The parameters to provide for the current
         MongoDB database. Is either a model type or a IO type. Required.
        :type create_update_mongo_db_database_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_mongo_db_database_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                create_update_mongo_db_database_parameters=create_update_mongo_db_database_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_mongo_db_database_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_mongo_db_resources_delete_mongo_db_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_mongo_db_database(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_mongo_db_database_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_mongo_db_database_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database
        account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_mongo_db_resources_get_mongo_db_database_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_mongo_db_database_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_mongo_db_resources_update_mongo_db_database_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_mongo_db_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of the an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current MongoDB database. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_mongo_db_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of the an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current MongoDB database. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_mongo_db_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of the an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current MongoDB database. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_mongo_db_database_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_mongo_db_database_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_mongo_db_resources_migrate_mongo_db_database_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_mongo_db_database_to_autoscale(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_mongo_db_database_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_mongo_db_database_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_mongo_db_resources_migrate_mongo_db_database_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_mongo_db_database_to_manual_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_mongo_db_database_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _mongo_db_database_retrieve_throughput_distribution_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(retrieve_throughput_parameters, (IO, bytes)):
            _content = retrieve_throughput_parameters
        else:
            _json = retrieve_throughput_parameters

        request = build_mongo_db_resources_mongo_db_database_retrieve_throughput_distribution_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_mongo_db_database_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current MongoDB database. Required.
        :type retrieve_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                retrieve_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "physicalPartitionIds": [
                                {
                                    "id": "str"  # Id of a physical partition.
                                      Required.
                                }
                            ]
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_mongo_db_database_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current MongoDB database. Required.
        :type retrieve_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_mongo_db_database_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current MongoDB database. Is either a model type or a IO type. Required.
        :type retrieve_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._mongo_db_database_retrieve_throughput_distribution_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                retrieve_throughput_parameters=retrieve_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _mongo_db_database_redistribute_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(redistribute_throughput_parameters, (IO, bytes)):
            _content = redistribute_throughput_parameters
        else:
            _json = redistribute_throughput_parameters

        request = build_mongo_db_resources_mongo_db_database_redistribute_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_mongo_db_database_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current MongoDB database. Required.
        :type redistribute_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                redistribute_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "sourcePhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "targetPhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "throughputPolicy": "str"  # ThroughputPolicy to apply for
                              throughput redistribution. Required. Known values are: "none", "equal",
                              and "custom".
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_mongo_db_database_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current MongoDB database. Required.
        :type redistribute_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_mongo_db_database_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB MongoDB database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current MongoDB database. Is either a model type or a IO type. Required.
        :type redistribute_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._mongo_db_database_redistribute_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                redistribute_throughput_parameters=redistribute_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _mongo_db_container_retrieve_throughput_distribution_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(retrieve_throughput_parameters, (IO, bytes)):
            _content = retrieve_throughput_parameters
        else:
            _json = retrieve_throughput_parameters

        request = build_mongo_db_resources_mongo_db_container_retrieve_throughput_distribution_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_mongo_db_container_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        retrieve_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB MongoDB container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current MongoDB container. Required.
        :type retrieve_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                retrieve_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "physicalPartitionIds": [
                                {
                                    "id": "str"  # Id of a physical partition.
                                      Required.
                                }
                            ]
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_mongo_db_container_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        retrieve_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB MongoDB container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current MongoDB container. Required.
        :type retrieve_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_mongo_db_container_retrieve_throughput_distribution(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        retrieve_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieve throughput distribution for an Azure Cosmos DB MongoDB container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param retrieve_throughput_parameters: The parameters to provide for retrieving throughput
         distribution for the current MongoDB container. Is either a model type or a IO type. Required.
        :type retrieve_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._mongo_db_container_retrieve_throughput_distribution_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                retrieve_throughput_parameters=retrieve_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _mongo_db_container_redistribute_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(redistribute_throughput_parameters, (IO, bytes)):
            _content = redistribute_throughput_parameters
        else:
            _json = redistribute_throughput_parameters

        request = build_mongo_db_resources_mongo_db_container_redistribute_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_mongo_db_container_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        redistribute_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB MongoDB container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current MongoDB container. Required.
        :type redistribute_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                redistribute_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "sourcePhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "targetPhysicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ],
                            "throughputPolicy": "str"  # ThroughputPolicy to apply for
                              throughput redistribution. Required. Known values are: "none", "equal",
                              and "custom".
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_mongo_db_container_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        redistribute_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB MongoDB container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current MongoDB container. Required.
        :type redistribute_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_mongo_db_container_redistribute_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        redistribute_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Redistribute throughput for an Azure Cosmos DB MongoDB container.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param redistribute_throughput_parameters: The parameters to provide for redistributing
         throughput for the current MongoDB container. Is either a model type or a IO type. Required.
        :type redistribute_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "physicalPartitionThroughputInfo": [
                                {
                                    "id": "str",  # Id of a physical partition.
                                      Required.
                                    "throughput": 0.0  # Optional. Throughput of
                                      a physical partition.
                                }
                            ]
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._mongo_db_container_redistribute_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                redistribute_throughput_parameters=redistribute_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_mongo_db_collections(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the MongoDB collection under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB collection.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "indexes": [
                                {
                                    "key": {
                                        "keys": [
                                            "str"  # Optional. List of
                                              keys for each MongoDB collection in the Azure Cosmos DB
                                              service.
                                        ]
                                    },
                                    "options": {
                                        "expireAfterSeconds": 0,  # Optional.
                                          Expire after seconds.
                                        "unique": bool  # Optional. Is unique
                                          or not.
                                    }
                                }
                            ],
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "shardKey": {
                                "str": "str"  # Optional. A key-value pair of shard
                                  keys to be applied for the request.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_mongo_db_resources_list_mongo_db_collections_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_mongo_db_collection(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the MongoDB collection under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB collection.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "indexes": [
                                {
                                    "key": {
                                        "keys": [
                                            "str"  # Optional. List of
                                              keys for each MongoDB collection in the Azure Cosmos DB
                                              service.
                                        ]
                                    },
                                    "options": {
                                        "expireAfterSeconds": 0,  # Optional.
                                          Expire after seconds.
                                        "unique": bool  # Optional. Is unique
                                          or not.
                                    }
                                }
                            ],
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "shardKey": {
                                "str": "str"  # Optional. A key-value pair of shard
                                  keys to be applied for the request.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_mongo_db_resources_get_mongo_db_collection_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_mongo_db_collection_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        create_update_mongo_db_collection_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_mongo_db_collection_parameters, (IO, bytes)):
            _content = create_update_mongo_db_collection_parameters
        else:
            _json = create_update_mongo_db_collection_parameters

        request = build_mongo_db_resources_create_update_mongo_db_collection_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_mongo_db_collection(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        create_update_mongo_db_collection_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param create_update_mongo_db_collection_parameters: The parameters to provide for the current
         MongoDB Collection. Required.
        :type create_update_mongo_db_collection_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_mongo_db_collection_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB collection.
                              Required.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "indexes": [
                                {
                                    "key": {
                                        "keys": [
                                            "str"  # Optional. List of
                                              keys for each MongoDB collection in the Azure Cosmos DB
                                              service.
                                        ]
                                    },
                                    "options": {
                                        "expireAfterSeconds": 0,  # Optional.
                                          Expire after seconds.
                                        "unique": bool  # Optional. Is unique
                                          or not.
                                    }
                                }
                            ],
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "shardKey": {
                                "str": "str"  # Optional. A key-value pair of shard
                                  keys to be applied for the request.
                            }
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB collection.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "indexes": [
                                {
                                    "key": {
                                        "keys": [
                                            "str"  # Optional. List of
                                              keys for each MongoDB collection in the Azure Cosmos DB
                                              service.
                                        ]
                                    },
                                    "options": {
                                        "expireAfterSeconds": 0,  # Optional.
                                          Expire after seconds.
                                        "unique": bool  # Optional. Is unique
                                          or not.
                                    }
                                }
                            ],
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "shardKey": {
                                "str": "str"  # Optional. A key-value pair of shard
                                  keys to be applied for the request.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_mongo_db_collection(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        create_update_mongo_db_collection_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param create_update_mongo_db_collection_parameters: The parameters to provide for the current
         MongoDB Collection. Required.
        :type create_update_mongo_db_collection_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB collection.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "indexes": [
                                {
                                    "key": {
                                        "keys": [
                                            "str"  # Optional. List of
                                              keys for each MongoDB collection in the Azure Cosmos DB
                                              service.
                                        ]
                                    },
                                    "options": {
                                        "expireAfterSeconds": 0,  # Optional.
                                          Expire after seconds.
                                        "unique": bool  # Optional. Is unique
                                          or not.
                                    }
                                }
                            ],
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "shardKey": {
                                "str": "str"  # Optional. A key-value pair of shard
                                  keys to be applied for the request.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_mongo_db_collection(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        create_update_mongo_db_collection_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param create_update_mongo_db_collection_parameters: The parameters to provide for the current
         MongoDB Collection. Is either a model type or a IO type. Required.
        :type create_update_mongo_db_collection_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB MongoDB collection.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "createMode": "Default",  # Optional. Default value is
                              "Default". Enum to indicate the mode of resource creation. Known values
                              are: "Default" and "Restore".
                            "indexes": [
                                {
                                    "key": {
                                        "keys": [
                                            "str"  # Optional. List of
                                              keys for each MongoDB collection in the Azure Cosmos DB
                                              service.
                                        ]
                                    },
                                    "options": {
                                        "expireAfterSeconds": 0,  # Optional.
                                          Expire after seconds.
                                        "unique": bool  # Optional. Is unique
                                          or not.
                                    }
                                }
                            ],
                            "restoreParameters": {
                                "restoreSource": "str",  # Optional. The id of the
                                  restorable database account from which the restore has to be
                                  initiated. For example:
                                  /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                "restoreTimestampInUtc": "2020-02-20 00:00:00"  #
                                  Optional. Time to which the account has to be restored (ISO-8601
                                  format).
                            },
                            "shardKey": {
                                "str": "str"  # Optional. A key-value pair of shard
                                  keys to be applied for the request.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_mongo_db_collection_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                create_update_mongo_db_collection_parameters=create_update_mongo_db_collection_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_mongo_db_collection_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_mongo_db_resources_delete_mongo_db_collection_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_mongo_db_collection(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_mongo_db_collection_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _list_mongo_db_collection_partition_merge_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        merge_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(merge_parameters, (IO, bytes)):
            _content = merge_parameters
        else:
            _json = merge_parameters

        request = build_mongo_db_resources_list_mongo_db_collection_partition_merge_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_list_mongo_db_collection_partition_merge(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        merge_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Merges the partitions of a MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param merge_parameters: The parameters for the merge operation. Required.
        :type merge_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                merge_parameters = {
                    "isDryRun": bool  # Optional. Specifies whether the operation is a real merge
                      operation or a simulation.
                }

                # response body for status code(s): 200
                response == {
                    "physicalPartitionStorageInfoCollection": [
                        {
                            "id": "str",  # Optional. The unique identifier of the
                              partition.
                            "storageInKB": 0.0  # Optional. The storage in KB for the
                              physical partition.
                        }
                    ]
                }
        """

    @overload
    async def begin_list_mongo_db_collection_partition_merge(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        merge_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Merges the partitions of a MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param merge_parameters: The parameters for the merge operation. Required.
        :type merge_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "physicalPartitionStorageInfoCollection": [
                        {
                            "id": "str",  # Optional. The unique identifier of the
                              partition.
                            "storageInKB": 0.0  # Optional. The storage in KB for the
                              physical partition.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def begin_list_mongo_db_collection_partition_merge(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        merge_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Merges the partitions of a MongoDB Collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param merge_parameters: The parameters for the merge operation. Is either a model type or a IO
         type. Required.
        :type merge_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "physicalPartitionStorageInfoCollection": [
                        {
                            "id": "str",  # Optional. The unique identifier of the
                              partition.
                            "storageInKB": 0.0  # Optional. The storage in KB for the
                              physical partition.
                        }
                    ]
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._list_mongo_db_collection_partition_merge_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                merge_parameters=merge_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_mongo_db_collection_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database
        account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_mongo_db_resources_get_mongo_db_collection_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_mongo_db_collection_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_mongo_db_resources_update_mongo_db_collection_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_mongo_db_collection_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update the RUs per second of an Azure Cosmos DB MongoDB collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current MongoDB collection. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_mongo_db_collection_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update the RUs per second of an Azure Cosmos DB MongoDB collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current MongoDB collection. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_mongo_db_collection_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update the RUs per second of an Azure Cosmos DB MongoDB collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current MongoDB collection. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_mongo_db_collection_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_mongo_db_collection_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_mongo_db_resources_migrate_mongo_db_collection_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_mongo_db_collection_to_autoscale(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_mongo_db_collection_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_mongo_db_collection_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_mongo_db_resources_migrate_mongo_db_collection_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_mongo_db_collection_to_manual_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, collection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_mongo_db_collection_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_mongo_role_definition(
        self, mongo_role_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> JSON:
        """Retrieves the properties of an existing Azure Cosmos DB Mongo Role Definition with the given
        Id.

        :param mongo_role_definition_id: The ID for the Role Definition {dbName.roleName}. Required.
        :type mongo_role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this Role Definition.
                        "privileges": [
                            {
                                "actions": [
                                    "str"  # Optional. An array of actions that
                                      are allowed.
                                ],
                                "resource": {
                                    "collection": "str",  # Optional. The
                                      collection name the role is applied.
                                    "db": "str"  # Optional. The database name
                                      the role is applied.
                                }
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_mongo_db_resources_get_mongo_role_definition_request(
            mongo_role_definition_id=mongo_role_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_mongo_role_definition_initial(
        self,
        mongo_role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_role_definition_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_mongo_role_definition_parameters, (IO, bytes)):
            _content = create_update_mongo_role_definition_parameters
        else:
            _json = create_update_mongo_role_definition_parameters

        request = build_mongo_db_resources_create_update_mongo_role_definition_request(
            mongo_role_definition_id=mongo_role_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_mongo_role_definition(
        self,
        mongo_role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_role_definition_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB Mongo Role Definition.

        :param mongo_role_definition_id: The ID for the Role Definition {dbName.roleName}. Required.
        :type mongo_role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_mongo_role_definition_parameters: The properties required to create or
         update a Role Definition. Required.
        :type create_update_mongo_role_definition_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_mongo_role_definition_parameters = {
                    "properties": {
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this Role Definition.
                        "privileges": [
                            {
                                "actions": [
                                    "str"  # Optional. An array of actions that
                                      are allowed.
                                ],
                                "resource": {
                                    "collection": "str",  # Optional. The
                                      collection name the role is applied.
                                    "db": "str"  # Optional. The database name
                                      the role is applied.
                                }
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this Role Definition.
                        "privileges": [
                            {
                                "actions": [
                                    "str"  # Optional. An array of actions that
                                      are allowed.
                                ],
                                "resource": {
                                    "collection": "str",  # Optional. The
                                      collection name the role is applied.
                                    "db": "str"  # Optional. The database name
                                      the role is applied.
                                }
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_mongo_role_definition(
        self,
        mongo_role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_role_definition_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB Mongo Role Definition.

        :param mongo_role_definition_id: The ID for the Role Definition {dbName.roleName}. Required.
        :type mongo_role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_mongo_role_definition_parameters: The properties required to create or
         update a Role Definition. Required.
        :type create_update_mongo_role_definition_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this Role Definition.
                        "privileges": [
                            {
                                "actions": [
                                    "str"  # Optional. An array of actions that
                                      are allowed.
                                ],
                                "resource": {
                                    "collection": "str",  # Optional. The
                                      collection name the role is applied.
                                    "db": "str"  # Optional. The database name
                                      the role is applied.
                                }
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_mongo_role_definition(
        self,
        mongo_role_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_role_definition_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB Mongo Role Definition.

        :param mongo_role_definition_id: The ID for the Role Definition {dbName.roleName}. Required.
        :type mongo_role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_mongo_role_definition_parameters: The properties required to create or
         update a Role Definition. Is either a model type or a IO type. Required.
        :type create_update_mongo_role_definition_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this Role Definition.
                        "privileges": [
                            {
                                "actions": [
                                    "str"  # Optional. An array of actions that
                                      are allowed.
                                ],
                                "resource": {
                                    "collection": "str",  # Optional. The
                                      collection name the role is applied.
                                    "db": "str"  # Optional. The database name
                                      the role is applied.
                                }
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_mongo_role_definition_initial(  # type: ignore
                mongo_role_definition_id=mongo_role_definition_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                create_update_mongo_role_definition_parameters=create_update_mongo_role_definition_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_mongo_role_definition_initial(  # pylint: disable=inconsistent-return-statements
        self, mongo_role_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_mongo_db_resources_delete_mongo_role_definition_request(
            mongo_role_definition_id=mongo_role_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_mongo_role_definition(
        self, mongo_role_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Mongo Role Definition.

        :param mongo_role_definition_id: The ID for the Role Definition {dbName.roleName}. Required.
        :type mongo_role_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_mongo_role_definition_initial(  # type: ignore
                mongo_role_definition_id=mongo_role_definition_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_mongo_role_definitions(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this Role Definition.
                        "privileges": [
                            {
                                "actions": [
                                    "str"  # Optional. An array of actions that
                                      are allowed.
                                ],
                                "resource": {
                                    "collection": "str",  # Optional. The
                                      collection name the role is applied.
                                    "db": "str"  # Optional. The database name
                                      the role is applied.
                                }
                            }
                        ],
                        "roleName": "str",  # Optional. A user-friendly name for the Role
                          Definition. Must be unique for the database account.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "type": "str"  # Optional. Indicates whether the Role Definition was
                          built-in or user created. Known values are: "BuiltInRole" and "CustomRole".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_mongo_db_resources_list_mongo_role_definitions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_mongo_user_definition(
        self, mongo_user_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> JSON:
        """Retrieves the properties of an existing Azure Cosmos DB Mongo User Definition with the given
        Id.

        :param mongo_user_definition_id: The ID for the User Definition {dbName.userName}. Required.
        :type mongo_user_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "customData": "str",  # Optional. A custom definition for the USer
                          Definition.
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this User Definition.
                        "mechanisms": "str",  # Optional. The Mongo Auth mechanism. For now,
                          we only support auth mechanism SCRAM-SHA-256.
                        "password": "str",  # Optional. The password for User Definition.
                          Response does not contain user password.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "userName": "str"  # Optional. The user name for User Definition.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_mongo_db_resources_get_mongo_user_definition_request(
            mongo_user_definition_id=mongo_user_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_mongo_user_definition_initial(
        self,
        mongo_user_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_user_definition_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_mongo_user_definition_parameters, (IO, bytes)):
            _content = create_update_mongo_user_definition_parameters
        else:
            _json = create_update_mongo_user_definition_parameters

        request = build_mongo_db_resources_create_update_mongo_user_definition_request(
            mongo_user_definition_id=mongo_user_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_mongo_user_definition(
        self,
        mongo_user_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_user_definition_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB Mongo User Definition.

        :param mongo_user_definition_id: The ID for the User Definition {dbName.userName}. Required.
        :type mongo_user_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_mongo_user_definition_parameters: The properties required to create or
         update a User Definition. Required.
        :type create_update_mongo_user_definition_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_mongo_user_definition_parameters = {
                    "properties": {
                        "customData": "str",  # Optional. A custom definition for the USer
                          Definition.
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this User Definition.
                        "mechanisms": "str",  # Optional. The Mongo Auth mechanism. For now,
                          we only support auth mechanism SCRAM-SHA-256.
                        "password": "str",  # Optional. The password for User Definition.
                          Response does not contain user password.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "userName": "str"  # Optional. The user name for User Definition.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "customData": "str",  # Optional. A custom definition for the USer
                          Definition.
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this User Definition.
                        "mechanisms": "str",  # Optional. The Mongo Auth mechanism. For now,
                          we only support auth mechanism SCRAM-SHA-256.
                        "password": "str",  # Optional. The password for User Definition.
                          Response does not contain user password.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "userName": "str"  # Optional. The user name for User Definition.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_mongo_user_definition(
        self,
        mongo_user_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_user_definition_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB Mongo User Definition.

        :param mongo_user_definition_id: The ID for the User Definition {dbName.userName}. Required.
        :type mongo_user_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_mongo_user_definition_parameters: The properties required to create or
         update a User Definition. Required.
        :type create_update_mongo_user_definition_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "customData": "str",  # Optional. A custom definition for the USer
                          Definition.
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this User Definition.
                        "mechanisms": "str",  # Optional. The Mongo Auth mechanism. For now,
                          we only support auth mechanism SCRAM-SHA-256.
                        "password": "str",  # Optional. The password for User Definition.
                          Response does not contain user password.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "userName": "str"  # Optional. The user name for User Definition.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_mongo_user_definition(
        self,
        mongo_user_definition_id: str,
        resource_group_name: str,
        account_name: str,
        create_update_mongo_user_definition_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates or updates an Azure Cosmos DB Mongo User Definition.

        :param mongo_user_definition_id: The ID for the User Definition {dbName.userName}. Required.
        :type mongo_user_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param create_update_mongo_user_definition_parameters: The properties required to create or
         update a User Definition. Is either a model type or a IO type. Required.
        :type create_update_mongo_user_definition_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "customData": "str",  # Optional. A custom definition for the USer
                          Definition.
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this User Definition.
                        "mechanisms": "str",  # Optional. The Mongo Auth mechanism. For now,
                          we only support auth mechanism SCRAM-SHA-256.
                        "password": "str",  # Optional. The password for User Definition.
                          Response does not contain user password.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "userName": "str"  # Optional. The user name for User Definition.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_mongo_user_definition_initial(  # type: ignore
                mongo_user_definition_id=mongo_user_definition_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                create_update_mongo_user_definition_parameters=create_update_mongo_user_definition_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_mongo_user_definition_initial(  # pylint: disable=inconsistent-return-statements
        self, mongo_user_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_mongo_db_resources_delete_mongo_user_definition_request(
            mongo_user_definition_id=mongo_user_definition_id,
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_mongo_user_definition(
        self, mongo_user_definition_id: str, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Mongo User Definition.

        :param mongo_user_definition_id: The ID for the User Definition {dbName.userName}. Required.
        :type mongo_user_definition_id: str
        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_mongo_user_definition_initial(  # type: ignore
                mongo_user_definition_id=mongo_user_definition_id,
                resource_group_name=resource_group_name,
                account_name=account_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_mongo_user_definitions(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Retrieves the list of all Azure Cosmos DB Mongo User Definition.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "customData": "str",  # Optional. A custom definition for the USer
                          Definition.
                        "databaseName": "str",  # Optional. The database name for which
                          access is being granted for this User Definition.
                        "mechanisms": "str",  # Optional. The Mongo Auth mechanism. For now,
                          we only support auth mechanism SCRAM-SHA-256.
                        "password": "str",  # Optional. The password for User Definition.
                          Response does not contain user password.
                        "roles": [
                            {
                                "db": "str",  # Optional. The database name the role
                                  is applied.
                                "role": "str"  # Optional. The role name.
                            }
                        ],
                        "userName": "str"  # Optional. The user name for User Definition.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_mongo_db_resources_list_mongo_user_definitions_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _retrieve_continuous_backup_information_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        location: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(location, (IO, bytes)):
            _content = location
        else:
            _json = location

        request = build_mongo_db_resources_retrieve_continuous_backup_information_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            collection_name=collection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        location: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a Mongodb collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                location = {
                    "location": "str"  # Optional. The name of the continuous backup restore
                      location.
                }

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        location: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a Mongodb collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @distributed_trace_async
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        collection_name: str,
        location: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a Mongodb collection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param collection_name: Cosmos DB collection name. Required.
        :type collection_name: str
        :param location: The name of the continuous backup restore location. Is either a model type or
         a IO type. Required.
        :type location: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._retrieve_continuous_backup_information_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                collection_name=collection_name,
                location=location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class TableResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`table_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_tables(self, resource_group_name: str, account_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists the Tables under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB table. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_table_resources_list_tables_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_table(self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any) -> JSON:
        """Gets the Tables under an existing Azure Cosmos DB database account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB table. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_table_resources_get_table_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_table_initial(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        create_update_table_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_table_parameters, (IO, bytes)):
            _content = create_update_table_parameters
        else:
            _json = create_update_table_parameters

        request = build_table_resources_create_update_table_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_table(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        create_update_table_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param create_update_table_parameters: The parameters to provide for the current Table.
         Required.
        :type create_update_table_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_table_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB table. Required.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB table. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_table(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        create_update_table_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param create_update_table_parameters: The parameters to provide for the current Table.
         Required.
        :type create_update_table_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB table. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_table(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        create_update_table_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param create_update_table_parameters: The parameters to provide for the current Table. Is
         either a model type or a IO type. Required.
        :type create_update_table_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB table. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_table_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                table_name=table_name,
                create_update_table_parameters=create_update_table_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_table_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_table_resources_delete_table_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_table(
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_table_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                table_name=table_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_table_throughput(
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the Table under an existing Azure Cosmos DB database account with
        the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_table_resources_get_table_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_table_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_table_resources_update_table_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_table_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current Table. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_table_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current Table. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_table_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param update_throughput_parameters: The parameters to provide for the RUs per second of the
         current Table. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_table_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                table_name=table_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_table_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_table_resources_migrate_table_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_table_to_autoscale(
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Table from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_table_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                table_name=table_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_table_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_table_resources_migrate_table_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_table_to_manual_throughput(
        self, resource_group_name: str, account_name: str, table_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Table from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_table_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                table_name=table_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _retrieve_continuous_backup_information_initial(
        self, resource_group_name: str, account_name: str, table_name: str, location: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(location, (IO, bytes)):
            _content = location
        else:
            _json = location

        request = build_table_resources_retrieve_continuous_backup_information_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        location: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                location = {
                    "location": "str"  # Optional. The name of the continuous backup restore
                      location.
                }

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        table_name: str,
        location: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @distributed_trace_async
    async def begin_retrieve_continuous_backup_information(
        self, resource_group_name: str, account_name: str, table_name: str, location: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param location: The name of the continuous backup restore location. Is either a model type or
         a IO type. Required.
        :type location: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._retrieve_continuous_backup_information_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                table_name=table_name,
                location=location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class CassandraResourcesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`cassandra_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_cassandra_keyspaces(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the Cassandra keyspaces under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra keyspace.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_resources_list_cassandra_keyspaces_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_cassandra_keyspace(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the Cassandra keyspaces under an existing Azure Cosmos DB database account with the
        provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra keyspace.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_resources_get_cassandra_keyspace_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_cassandra_keyspace_initial(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        create_update_cassandra_keyspace_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_cassandra_keyspace_parameters, (IO, bytes)):
            _content = create_update_cassandra_keyspace_parameters
        else:
            _json = create_update_cassandra_keyspace_parameters

        request = build_cassandra_resources_create_update_cassandra_keyspace_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_cassandra_keyspace(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        create_update_cassandra_keyspace_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param create_update_cassandra_keyspace_parameters: The parameters to provide for the current
         Cassandra keyspace. Required.
        :type create_update_cassandra_keyspace_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_cassandra_keyspace_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Cassandra keyspace.
                              Required.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra keyspace.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_cassandra_keyspace(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        create_update_cassandra_keyspace_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param create_update_cassandra_keyspace_parameters: The parameters to provide for the current
         Cassandra keyspace. Required.
        :type create_update_cassandra_keyspace_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra keyspace.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_cassandra_keyspace(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        create_update_cassandra_keyspace_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param create_update_cassandra_keyspace_parameters: The parameters to provide for the current
         Cassandra keyspace. Is either a model type or a IO type. Required.
        :type create_update_cassandra_keyspace_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra keyspace.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_cassandra_keyspace_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                create_update_cassandra_keyspace_parameters=create_update_cassandra_keyspace_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_cassandra_keyspace_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_resources_delete_cassandra_keyspace_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_cassandra_keyspace(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Cassandra keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_cassandra_keyspace_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_cassandra_keyspace_throughput(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the Cassandra Keyspace under an existing Azure Cosmos DB database
        account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_resources_get_cassandra_keyspace_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_cassandra_keyspace_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_cassandra_resources_update_cassandra_keyspace_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_cassandra_keyspace_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra Keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra Keyspace. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_cassandra_keyspace_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra Keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra Keyspace. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_cassandra_keyspace_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra Keyspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra Keyspace. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_cassandra_keyspace_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_cassandra_keyspace_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_cassandra_resources_migrate_cassandra_keyspace_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_cassandra_keyspace_to_autoscale(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Cassandra Keyspace from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_cassandra_keyspace_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_cassandra_keyspace_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_cassandra_resources_migrate_cassandra_keyspace_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_cassandra_keyspace_to_manual_throughput(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Cassandra Keyspace from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_cassandra_keyspace_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_cassandra_tables(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the Cassandra table under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra table.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "defaultTtl": 0,  # Optional. Time to live of the Cosmos DB
                              Cassandra table.
                            "schema": {
                                "clusterKeys": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table cluster key.
                                        "orderBy": "str"  # Optional. Order
                                          of the Cosmos DB Cassandra table cluster key, only support
                                          "Asc" and "Desc".
                                    }
                                ],
                                "columns": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table column.
                                        "type": "str"  # Optional. Type of
                                          the Cosmos DB Cassandra table column.
                                    }
                                ],
                                "partitionKeys": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the Cosmos DB Cassandra table partition key.
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_resources_list_cassandra_tables_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    keyspace_name=keyspace_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_cassandra_table(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the Cassandra table under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra table.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "defaultTtl": 0,  # Optional. Time to live of the Cosmos DB
                              Cassandra table.
                            "schema": {
                                "clusterKeys": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table cluster key.
                                        "orderBy": "str"  # Optional. Order
                                          of the Cosmos DB Cassandra table cluster key, only support
                                          "Asc" and "Desc".
                                    }
                                ],
                                "columns": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table column.
                                        "type": "str"  # Optional. Type of
                                          the Cosmos DB Cassandra table column.
                                    }
                                ],
                                "partitionKeys": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the Cosmos DB Cassandra table partition key.
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_resources_get_cassandra_table_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_cassandra_table_initial(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        create_update_cassandra_table_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_cassandra_table_parameters, (IO, bytes)):
            _content = create_update_cassandra_table_parameters
        else:
            _json = create_update_cassandra_table_parameters

        request = build_cassandra_resources_create_update_cassandra_table_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_cassandra_table(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        create_update_cassandra_table_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param create_update_cassandra_table_parameters: The parameters to provide for the current
         Cassandra Table. Required.
        :type create_update_cassandra_table_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_cassandra_table_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra table.
                              Required.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "defaultTtl": 0,  # Optional. Time to live of the Cosmos DB
                              Cassandra table.
                            "schema": {
                                "clusterKeys": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table cluster key.
                                        "orderBy": "str"  # Optional. Order
                                          of the Cosmos DB Cassandra table cluster key, only support
                                          "Asc" and "Desc".
                                    }
                                ],
                                "columns": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table column.
                                        "type": "str"  # Optional. Type of
                                          the Cosmos DB Cassandra table column.
                                    }
                                ],
                                "partitionKeys": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the Cosmos DB Cassandra table partition key.
                                    }
                                ]
                            }
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra table.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "defaultTtl": 0,  # Optional. Time to live of the Cosmos DB
                              Cassandra table.
                            "schema": {
                                "clusterKeys": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table cluster key.
                                        "orderBy": "str"  # Optional. Order
                                          of the Cosmos DB Cassandra table cluster key, only support
                                          "Asc" and "Desc".
                                    }
                                ],
                                "columns": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table column.
                                        "type": "str"  # Optional. Type of
                                          the Cosmos DB Cassandra table column.
                                    }
                                ],
                                "partitionKeys": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the Cosmos DB Cassandra table partition key.
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_cassandra_table(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        create_update_cassandra_table_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param create_update_cassandra_table_parameters: The parameters to provide for the current
         Cassandra Table. Required.
        :type create_update_cassandra_table_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra table.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "defaultTtl": 0,  # Optional. Time to live of the Cosmos DB
                              Cassandra table.
                            "schema": {
                                "clusterKeys": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table cluster key.
                                        "orderBy": "str"  # Optional. Order
                                          of the Cosmos DB Cassandra table cluster key, only support
                                          "Asc" and "Desc".
                                    }
                                ],
                                "columns": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table column.
                                        "type": "str"  # Optional. Type of
                                          the Cosmos DB Cassandra table column.
                                    }
                                ],
                                "partitionKeys": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the Cosmos DB Cassandra table partition key.
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_cassandra_table(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        create_update_cassandra_table_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra Table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param create_update_cassandra_table_parameters: The parameters to provide for the current
         Cassandra Table. Is either a model type or a IO type. Required.
        :type create_update_cassandra_table_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra table.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "defaultTtl": 0,  # Optional. Time to live of the Cosmos DB
                              Cassandra table.
                            "schema": {
                                "clusterKeys": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table cluster key.
                                        "orderBy": "str"  # Optional. Order
                                          of the Cosmos DB Cassandra table cluster key, only support
                                          "Asc" and "Desc".
                                    }
                                ],
                                "columns": [
                                    {
                                        "name": "str",  # Optional. Name of
                                          the Cosmos DB Cassandra table column.
                                        "type": "str"  # Optional. Type of
                                          the Cosmos DB Cassandra table column.
                                    }
                                ],
                                "partitionKeys": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the Cosmos DB Cassandra table partition key.
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_cassandra_table_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                table_name=table_name,
                create_update_cassandra_table_parameters=create_update_cassandra_table_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_cassandra_table_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_resources_delete_cassandra_table_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_cassandra_table(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Cassandra table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_cassandra_table_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                table_name=table_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_cassandra_table_throughput(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the Cassandra table under an existing Azure Cosmos DB database
        account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_resources_get_cassandra_table_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_cassandra_table_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_cassandra_resources_update_cassandra_table_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_cassandra_table_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra table. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_cassandra_table_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra table. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_cassandra_table_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        table_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra table.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra table. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_cassandra_table_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                table_name=table_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_cassandra_table_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_cassandra_resources_migrate_cassandra_table_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_cassandra_table_to_autoscale(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Cassandra table from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_cassandra_table_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                table_name=table_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_cassandra_table_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_cassandra_resources_migrate_cassandra_table_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            table_name=table_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_cassandra_table_to_manual_throughput(
        self, resource_group_name: str, account_name: str, keyspace_name: str, table_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Cassandra table from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param table_name: Cosmos DB table name. Required.
        :type table_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_cassandra_table_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                table_name=table_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_cassandra_views(
        self, resource_group_name: str, account_name: str, keyspace_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the Cassandra materialized views under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra view.
                              Required.
                            "viewDefinition": "str",  # View Definition of the Cosmos DB
                              Cassandra view. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_resources_list_cassandra_views_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    keyspace_name=keyspace_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_cassandra_view(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the Cassandra view under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra view.
                              Required.
                            "viewDefinition": "str",  # View Definition of the Cosmos DB
                              Cassandra view. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_resources_get_cassandra_view_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_cassandra_view_initial(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        create_update_cassandra_view_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_cassandra_view_parameters, (IO, bytes)):
            _content = create_update_cassandra_view_parameters
        else:
            _json = create_update_cassandra_view_parameters

        request = build_cassandra_resources_create_update_cassandra_view_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_cassandra_view(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        create_update_cassandra_view_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra View.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :param create_update_cassandra_view_parameters: The parameters to provide for the current
         Cassandra View. Required.
        :type create_update_cassandra_view_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_cassandra_view_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra view.
                              Required.
                            "viewDefinition": "str"  # View Definition of the Cosmos DB
                              Cassandra view. Required.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra view.
                              Required.
                            "viewDefinition": "str",  # View Definition of the Cosmos DB
                              Cassandra view. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_cassandra_view(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        create_update_cassandra_view_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra View.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :param create_update_cassandra_view_parameters: The parameters to provide for the current
         Cassandra View. Required.
        :type create_update_cassandra_view_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra view.
                              Required.
                            "viewDefinition": "str",  # View Definition of the Cosmos DB
                              Cassandra view. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_cassandra_view(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        create_update_cassandra_view_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Cassandra View.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :param create_update_cassandra_view_parameters: The parameters to provide for the current
         Cassandra View. Is either a model type or a IO type. Required.
        :type create_update_cassandra_view_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Cassandra view.
                              Required.
                            "viewDefinition": "str",  # View Definition of the Cosmos DB
                              Cassandra view. Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_cassandra_view_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                view_name=view_name,
                create_update_cassandra_view_parameters=create_update_cassandra_view_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_cassandra_view_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_resources_delete_cassandra_view_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_cassandra_view(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Cassandra view.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_cassandra_view_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                view_name=view_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_cassandra_view_throughput(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the Cassandra view under an existing Azure Cosmos DB database
        account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_resources_get_cassandra_view_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_cassandra_view_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_cassandra_resources_update_cassandra_view_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_cassandra_view_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra view.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra view. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_cassandra_view_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra view.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra view. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_cassandra_view_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        keyspace_name: str,
        view_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Cassandra view.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Cassandra view. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_cassandra_view_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                view_name=view_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_cassandra_view_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_cassandra_resources_migrate_cassandra_view_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_cassandra_view_to_autoscale(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Cassandra view from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_cassandra_view_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                view_name=view_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_cassandra_view_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_cassandra_resources_migrate_cassandra_view_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            keyspace_name=keyspace_name,
            view_name=view_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_cassandra_view_to_manual_throughput(
        self, resource_group_name: str, account_name: str, keyspace_name: str, view_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Cassandra view from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param keyspace_name: Cosmos DB keyspace name. Required.
        :type keyspace_name: str
        :param view_name: Cosmos DB view name. Required.
        :type view_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_cassandra_view_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                keyspace_name=keyspace_name,
                view_name=view_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class GremlinResourcesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`gremlin_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_gremlin_databases(self, resource_group_name: str, account_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists the Gremlin databases under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_gremlin_resources_list_gremlin_databases_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_gremlin_database(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the Gremlin databases under an existing Azure Cosmos DB database account with the provided
        name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_gremlin_resources_get_gremlin_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_gremlin_database_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_gremlin_database_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_gremlin_database_parameters, (IO, bytes)):
            _content = create_update_gremlin_database_parameters
        else:
            _json = create_update_gremlin_database_parameters

        request = build_gremlin_resources_create_update_gremlin_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_gremlin_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_gremlin_database_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_gremlin_database_parameters: The parameters to provide for the current
         Gremlin database. Required.
        :type create_update_gremlin_database_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_gremlin_database_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str"  # Name of the Cosmos DB Gremlin database.
                              Required.
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_gremlin_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_gremlin_database_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_gremlin_database_parameters: The parameters to provide for the current
         Gremlin database. Required.
        :type create_update_gremlin_database_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_gremlin_database(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        create_update_gremlin_database_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param create_update_gremlin_database_parameters: The parameters to provide for the current
         Gremlin database. Is either a model type or a IO type. Required.
        :type create_update_gremlin_database_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin database.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_gremlin_database_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                create_update_gremlin_database_parameters=create_update_gremlin_database_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_gremlin_database_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_gremlin_resources_delete_gremlin_database_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_gremlin_database(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_gremlin_database_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_gremlin_database_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the RUs per second of the Gremlin database under an existing Azure Cosmos DB database
        account with the provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_gremlin_resources_get_gremlin_database_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_gremlin_database_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_gremlin_resources_update_gremlin_database_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_gremlin_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Gremlin database. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_gremlin_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Gremlin database. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_gremlin_database_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Gremlin database.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Gremlin database. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_gremlin_database_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_gremlin_database_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_gremlin_resources_migrate_gremlin_database_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_gremlin_database_to_autoscale(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_gremlin_database_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_gremlin_database_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_gremlin_resources_migrate_gremlin_database_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_gremlin_database_to_manual_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_gremlin_database_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_gremlin_graphs(
        self, resource_group_name: str, account_name: str, database_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists the Gremlin graph under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin graph.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_gremlin_resources_list_gremlin_graphs_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    database_name=database_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_gremlin_graph(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the Gremlin graph under an existing Azure Cosmos DB database account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin graph.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_gremlin_resources_get_gremlin_graph_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_update_gremlin_graph_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        create_update_gremlin_graph_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_gremlin_graph_parameters, (IO, bytes)):
            _content = create_update_gremlin_graph_parameters
        else:
            _json = create_update_gremlin_graph_parameters

        request = build_gremlin_resources_create_update_gremlin_graph_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_update_gremlin_graph(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        create_update_gremlin_graph_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param create_update_gremlin_graph_parameters: The parameters to provide for the current
         Gremlin graph. Required.
        :type create_update_gremlin_graph_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_gremlin_graph_parameters = {
                    "properties": {
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin graph.
                              Required.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        },
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Request Units per second. For
                              example, "throughput": 10000.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin graph.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update_gremlin_graph(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        create_update_gremlin_graph_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param create_update_gremlin_graph_parameters: The parameters to provide for the current
         Gremlin graph. Required.
        :type create_update_gremlin_graph_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin graph.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update_gremlin_graph(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        create_update_gremlin_graph_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update an Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param create_update_gremlin_graph_parameters: The parameters to provide for the current
         Gremlin graph. Is either a model type or a IO type. Required.
        :type create_update_gremlin_graph_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "options": {
                            "autoscaleSettings": {
                                "maxThroughput": 0  # Optional. Represents maximum
                                  throughput, the resource can scale up to.
                            },
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput or autoscaleSettings. Use the ThroughputSetting resource when
                              retrieving offer details.
                        },
                        "resource": {
                            "id": "str",  # Name of the Cosmos DB Gremlin graph.
                              Required.
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "analyticalStorageTtl": 0,  # Optional. Analytical TTL.
                            "conflictResolutionPolicy": {
                                "conflictResolutionPath": "str",  # Optional. The
                                  conflict resolution path in the case of LastWriterWins mode.
                                "conflictResolutionProcedure": "str",  # Optional.
                                  The procedure to resolve conflicts in the case of custom mode.
                                "mode": "LastWriterWins"  # Optional. Default value
                                  is "LastWriterWins". Indicates the conflict resolution mode. Known
                                  values are: "LastWriterWins" and "Custom".
                            },
                            "defaultTtl": 0,  # Optional. Default time to live.
                            "indexingPolicy": {
                                "automatic": bool,  # Optional. Indicates if the
                                  indexing policy is automatic.
                                "compositeIndexes": [
                                    [
                                        {
                                            "order": "str",  # Optional.
                                              Sort order for composite paths. Known values are:
                                              "ascending" and "descending".
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ]
                                ],
                                "excludedPaths": [
                                    {
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "includedPaths": [
                                    {
                                        "indexes": [
                                            {
                                                "dataType": "String",
                                                  # Optional. Default value is "String". The datatype
                                                  for which the indexing behavior is applied to. Known
                                                  values are: "String", "Number", "Point", "Polygon",
                                                  "LineString", and "MultiPolygon".
                                                "kind": "Hash",  #
                                                  Optional. Default value is "Hash". Indicates the type
                                                  of index. Known values are: "Hash", "Range", and
                                                  "Spatial".
                                                "precision": 0  #
                                                  Optional. The precision of the index. -1 is maximum
                                                  precision.
                                            }
                                        ],
                                        "path": "str"  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                    }
                                ],
                                "indexingMode": "consistent",  # Optional. Default
                                  value is "consistent". Indicates the indexing mode. Known values are:
                                  "consistent", "lazy", and "none".
                                "spatialIndexes": [
                                    {
                                        "path": "str",  # Optional. The path
                                          for which the indexing behavior applies to. Index paths
                                          typically start with root and end with wildcard (/path/*).
                                        "types": [
                                            "str"  # Optional. List of
                                              path's spatial type.
                                        ]
                                    }
                                ]
                            },
                            "partitionKey": {
                                "kind": "Hash",  # Optional. Default value is "Hash".
                                  Indicates the kind of algorithm used for partitioning. For MultiHash,
                                  multiple partition keys (upto three maximum) are supported for
                                  container create. Known values are: "Hash", "Range", and "MultiHash".
                                "paths": [
                                    "str"  # Optional. List of paths using which
                                      data within the container can be partitioned.
                                ],
                                "systemKey": bool,  # Optional. Indicates if the
                                  container is using a system generated partition key.
                                "version": 0  # Optional. Indicates the version of
                                  the partition key definition.
                            },
                            "uniqueKeyPolicy": {
                                "uniqueKeys": [
                                    {
                                        "paths": [
                                            "str"  # Optional. List of
                                              paths must be unique for each document in the Azure
                                              Cosmos DB service.
                                        ]
                                    }
                                ]
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_gremlin_graph_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                graph_name=graph_name,
                create_update_gremlin_graph_parameters=create_update_gremlin_graph_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_gremlin_graph_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_gremlin_resources_delete_gremlin_graph_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete_gremlin_graph(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes an existing Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_gremlin_graph_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                graph_name=graph_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get_gremlin_graph_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the Gremlin graph throughput under an existing Azure Cosmos DB database account with the
        provided name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_gremlin_resources_get_gremlin_graph_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _update_gremlin_graph_throughput_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_throughput_parameters, (IO, bytes)):
            _content = update_throughput_parameters
        else:
            _json = update_throughput_parameters

        request = build_gremlin_resources_update_gremlin_graph_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_update_gremlin_graph_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        update_throughput_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Gremlin graph. Required.
        :type update_throughput_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_throughput_parameters = {
                    "properties": {
                        "resource": {
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update_gremlin_graph_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        update_throughput_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Gremlin graph. Required.
        :type update_throughput_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update_gremlin_graph_throughput(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        update_throughput_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update RUs per second of an Azure Cosmos DB Gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param update_throughput_parameters: The RUs per second of the parameters to provide for the
         current Gremlin graph. Is either a model type or a IO type. Required.
        :type update_throughput_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_gremlin_graph_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                graph_name=graph_name,
                update_throughput_parameters=update_throughput_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_gremlin_graph_to_autoscale_initial(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_gremlin_resources_migrate_gremlin_graph_to_autoscale_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_gremlin_graph_to_autoscale(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_gremlin_graph_to_autoscale_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                graph_name=graph_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _migrate_gremlin_graph_to_manual_throughput_initial(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_gremlin_resources_migrate_gremlin_graph_to_manual_throughput_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def begin_migrate_gremlin_graph_to_manual_throughput(
        self, resource_group_name: str, account_name: str, database_name: str, graph_name: str, **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The principal id of the system
                          assigned identity. This property will only be provided for a system assigned
                          identity.
                        "tenantId": "str",  # Optional. The tenant id of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "type": "str",  # Optional. The type of identity used for the
                          resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly
                          created identity and a set of user assigned identities. The type 'None' will
                          remove any identities from the service. Known values are: "SystemAssigned",
                          "UserAssigned", "SystemAssigned,UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_etag": "str",  # Optional. A system generated property
                              representing the resource etag required for optimistic concurrency
                              control.
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "_ts": 0.0,  # Optional. A system generated property that
                              denotes the last updated timestamp of the resource.
                            "autoscaleSettings": {
                                "maxThroughput": 0,  # Represents maximum throughput
                                  container can scale up to. Required.
                                "autoUpgradePolicy": {
                                    "throughputPolicy": {
                                        "incrementPercent": 0,  # Optional.
                                          Represents the percentage by which throughput can increase
                                          every time throughput policy kicks in.
                                        "isEnabled": bool  # Optional.
                                          Determines whether the ThroughputPolicy is active or not.
                                    }
                                },
                                "targetMaxThroughput": 0  # Optional. Represents
                                  target maximum throughput container can scale up to once offer is no
                                  longer in pending state.
                            },
                            "minimumThroughput": "str",  # Optional. The minimum
                              throughput of the resource.
                            "offerReplacePending": "str",  # Optional. The throughput
                              replace is pending.
                            "throughput": 0  # Optional. Value of the Cosmos DB resource
                              throughput. Either throughput is required or autoscaleSettings is
                              required, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._migrate_gremlin_graph_to_manual_throughput_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                graph_name=graph_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _retrieve_continuous_backup_information_initial(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        location: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(location, (IO, bytes)):
            _content = location
        else:
            _json = location

        request = build_gremlin_resources_retrieve_continuous_backup_information_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            database_name=database_name,
            graph_name=graph_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        location: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                location = {
                    "location": "str"  # Optional. The name of the continuous backup restore
                      location.
                }

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @overload
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        location: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param location: The name of the continuous backup restore location. Required.
        :type location: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """

    @distributed_trace_async
    async def begin_retrieve_continuous_backup_information(
        self,
        resource_group_name: str,
        account_name: str,
        database_name: str,
        graph_name: str,
        location: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Retrieves continuous backup information for a gremlin graph.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param database_name: Cosmos DB database name. Required.
        :type database_name: str
        :param graph_name: Cosmos DB graph name. Required.
        :type graph_name: str
        :param location: The name of the continuous backup restore location. Is either a model type or
         a IO type. Required.
        :type location: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuousBackupInformation": {
                        "latestRestorableTimestamp": "str"  # Optional. The latest restorable
                          timestamp for a resource.
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._retrieve_continuous_backup_information_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                database_name=database_name,
                graph_name=graph_name,
                location=location,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class LocationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`locations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable[JSON]:
        """List Cosmos DB locations and their properties.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "backupStorageRedundancies": [
                            "str"  # Optional. The properties of available backup storage
                              redundancies.
                        ],
                        "isResidencyRestricted": bool,  # Optional. Flag indicating whether
                          the location is residency sensitive.
                        "status": "str",  # Optional. The current status of location in
                          Azure.
                        "supportsAvailabilityZone": bool  # Optional. Flag indicating whether
                          the location supports availability zones or not.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_locations_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, location: str, **kwargs: Any) -> JSON:
        """Get the properties of an existing Cosmos DB location.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "backupStorageRedundancies": [
                            "str"  # Optional. The properties of available backup storage
                              redundancies.
                        ],
                        "isResidencyRestricted": bool,  # Optional. Flag indicating whether
                          the location is residency sensitive.
                        "status": "str",  # Optional. The current status of location in
                          Azure.
                        "supportsAvailabilityZone": bool  # Optional. Flag indicating whether
                          the location supports availability zones or not.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_locations_get_request(
            location=location,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class DataTransferJobsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`data_transfer_jobs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        resource_group_name: str,
        account_name: str,
        job_name: str,
        job_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :param job_create_parameters: Required.
        :type job_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # JSON input template you can fill out and use as your body input.
                job_create_parameters = {
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "type": "str"  # Optional. The type of Azure resource.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def create(
        self,
        resource_group_name: str,
        account_name: str,
        job_name: str,
        job_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :param job_create_parameters: Required.
        :type job_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def create(
        self,
        resource_group_name: str,
        account_name: str,
        job_name: str,
        job_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Creates a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :param job_create_parameters: Is either a model type or a IO type. Required.
        :type job_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job_create_parameters, (IO, bytes)):
            _content = job_create_parameters
        else:
            _json = job_create_parameters

        request = build_data_transfer_jobs_create_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            job_name=job_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get(self, resource_group_name: str, account_name: str, job_name: str, **kwargs: Any) -> JSON:
        """Get a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_data_transfer_jobs_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            job_name=job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def pause(self, resource_group_name: str, account_name: str, job_name: str, **kwargs: Any) -> JSON:
        """Pause a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_data_transfer_jobs_pause_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            job_name=job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def resume(self, resource_group_name: str, account_name: str, job_name: str, **kwargs: Any) -> JSON:
        """Resumes a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_data_transfer_jobs_resume_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            job_name=job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def cancel(self, resource_group_name: str, account_name: str, job_name: str, **kwargs: Any) -> JSON:
        """Cancels a Data Transfer Job.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param job_name: Name of the Data Transfer Job. Required.
        :type job_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_data_transfer_jobs_cancel_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            job_name=job_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_database_account(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Get a list of Data Transfer jobs.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "component":

                # JSON input template for discriminator value "AzureBlobStorage":
                data_transfer_data_source_sink = {
                    "component": "AzureBlobStorage",
                    "containerName": "str",  # Required.
                    "endpointUrl": "str"  # Optional.
                }

                # JSON input template for discriminator value "CosmosDBCassandra":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBCassandra",
                    "keyspaceName": "str",  # Required.
                    "tableName": "str"  # Required.
                }

                # JSON input template for discriminator value "CosmosDBSql":
                data_transfer_data_source_sink = {
                    "component": "CosmosDBSql",
                    "containerName": "str",  # Required.
                    "databaseName": "str"  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "destination": data_transfer_data_source_sink,
                        "source": data_transfer_data_source_sink,
                        "error": {
                            "code": "str",  # Optional. Error code.
                            "message": "str"  # Optional. Error message indicating why
                              the operation failed.
                        },
                        "jobName": "str",  # Optional. Job Name.
                        "lastUpdatedUtcTime": "2020-02-20 00:00:00",  # Optional. Last
                          Updated Time (ISO-8601 format).
                        "processedCount": 0,  # Optional. Processed Count.
                        "status": "str",  # Optional. Job Status.
                        "totalCount": 0,  # Optional. Total Count.
                        "workerCount": 0  # Optional. Worker count.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_data_transfer_jobs_list_by_database_account_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class CassandraClustersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`cassandra_clusters` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable[JSON]:
        """List all managed Cassandra clusters in this subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_clusters_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """List all managed Cassandra clusters in this resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_clusters_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> JSON:
        """Get the properties of a managed Cassandra cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_clusters_get_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, cluster_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_clusters_delete_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
        """Deletes a managed Cassandra cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _create_update_initial(
        self, resource_group_name: str, cluster_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_cassandra_clusters_create_update_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_create_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a managed Cassandra cluster. When updating, you must specify all writable
        properties. To update only some properties, use PATCH.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: The properties specifying the desired state of the managed Cassandra cluster.
         Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a managed Cassandra cluster. When updating, you must specify all writable
        properties. To update only some properties, use PATCH.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: The properties specifying the desired state of the managed Cassandra cluster.
         Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update(
        self, resource_group_name: str, cluster_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a managed Cassandra cluster. When updating, you must specify all writable
        properties. To update only some properties, use PATCH.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: The properties specifying the desired state of the managed Cassandra cluster. Is
         either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _update_initial(
        self, resource_group_name: str, cluster_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_cassandra_clusters_update_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Updates some of the properties of a managed Cassandra cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: Parameters to provide for specifying the managed Cassandra cluster. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Updates some of the properties of a managed Cassandra cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: Parameters to provide for specifying the managed Cassandra cluster. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update(
        self, resource_group_name: str, cluster_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Updates some of the properties of a managed Cassandra cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: Parameters to provide for specifying the managed Cassandra cluster. Is either a
         model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "identity": {
                        "principalId": "str",  # Optional. The object id of the identity
                          resource.
                        "tenantId": "str",  # Optional. The tenant id of the resource.
                        "type": "str"  # Optional. The type of the resource. Known values
                          are: "SystemAssigned" and "None".
                    },
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "authenticationMethod": "str",  # Optional. Which authentication
                          method Cassandra should use to authenticate clients. 'None' turns off
                          authentication, so should not be used except in emergencies. 'Cassandra' is
                          the default password based authentication. The default is 'Cassandra'. 'Ldap'
                          is in preview. Known values are: "None", "Cassandra", and "Ldap".
                        "cassandraAuditLoggingEnabled": bool,  # Optional. Whether Cassandra
                          audit logging is enabled.
                        "cassandraVersion": "str",  # Optional. Which version of Cassandra
                          should this cluster converge to running (e.g., 3.11). When updated, the
                          cluster may take some time to migrate to the new version.
                        "clientCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "clusterNameOverride": "str",  # Optional. If you need to set the
                          clusterName property in cassandra.yaml to something besides the resource name
                          of the cluster, set the value to use on this property.
                        "deallocated": bool,  # Optional. Whether the cluster and associated
                          data centers has been deallocated.
                        "delegatedManagementSubnetId": "str",  # Optional. Resource id of a
                          subnet that this cluster's management service should have its network
                          interface attached to. The subnet must be routable to all subnets that will
                          be delegated to data centers. The resource id must be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "externalGossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "externalSeedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "gossipCertificates": [
                            {
                                "pem": "str"  # Optional. PEM formatted public key.
                            }
                        ],
                        "hoursBetweenBackups": 0,  # Optional. Number of hours to wait
                          between taking a backup of the cluster.
                        "initialCassandraAdminPassword": "str",  # Optional. Initial password
                          for clients connecting as admin to the cluster. Should be changed after
                          cluster creation. Returns null on GET. This field only applies when the
                          authenticationMethod field is 'Cassandra'.
                        "prometheusEndpoint": {
                            "ipAddress": "str"  # Optional. IP address of this seed node.
                        },
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "repairEnabled": bool,  # Optional. Should automatic repairs run on
                          this cluster? If omitted, this is true, and should stay true unless you are
                          running a hybrid cluster where you are already doing your own repairs.
                        "restoreFromBackupId": "str",  # Optional. To create an empty
                          cluster, omit this field or set it to null. To restore a backup into a new
                          cluster, set this field to the resource id of the backup.
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Tags are a list of key-value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater than 128 characters and value
                          no greater than 256 characters. For example, the default experience for a
                          template type is set with "defaultExperience": "Cassandra". Current
                          "defaultExperience" values also include "Table", "Graph", "DocumentDB", and
                          "MongoDB".
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _invoke_command_initial(
        self, resource_group_name: str, cluster_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_cassandra_clusters_invoke_command_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_invoke_command(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Invoke a command like nodetool for cassandra maintenance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: Specification which command to run where. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "command": "str",  # The command which should be run. Required.
                    "host": "str",  # IP address of the cassandra host to run the command on.
                      Required.
                    "arguments": {
                        "str": "str"  # Optional. The arguments for the command to be run.
                    },
                    "cassandra-stop-start": bool,  # Optional. If true, stops cassandra before
                      executing the command and then start it again.
                    "readwrite": bool  # Optional. If true, allows the command to *write* to the
                      cassandra directory, otherwise read-only.
                }

                # response body for status code(s): 202
                response == {
                    "commandOutput": "str"  # Optional. Output of the command.
                }
        """

    @overload
    async def begin_invoke_command(
        self,
        resource_group_name: str,
        cluster_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Invoke a command like nodetool for cassandra maintenance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: Specification which command to run where. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "commandOutput": "str"  # Optional. Output of the command.
                }
        """

    @distributed_trace_async
    async def begin_invoke_command(
        self, resource_group_name: str, cluster_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Invoke a command like nodetool for cassandra maintenance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param body: Specification which command to run where. Is either a model type or a IO type.
         Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "commandOutput": "str"  # Optional. Output of the command.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._invoke_command_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_backups(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """List the backups of this cluster that are available to restore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The time this backup
                          was taken, formatted like 2021-01-21T17:35:21.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_clusters_list_backups_request(
                    resource_group_name=resource_group_name,
                    cluster_name=cluster_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_backup(self, resource_group_name: str, cluster_name: str, backup_id: str, **kwargs: Any) -> JSON:
        """Get the properties of an individual backup of this cluster that is available to restore.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param backup_id: Id of a restorable backup of a Cassandra cluster. Required.
        :type backup_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The time this backup
                          was taken, formatted like 2021-01-21T17:35:21.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_clusters_get_backup_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            backup_id=backup_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _deallocate_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, cluster_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_clusters_deallocate_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_deallocate(
        self, resource_group_name: str, cluster_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deallocate the Managed Cassandra Cluster and Associated Data Centers. Deallocation will
        deallocate the host virtual machine of this cluster, and reserved the data disk. This won't do
        anything on an already deallocated cluster. Use Start to restart the cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._deallocate_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _start_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, cluster_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_clusters_start_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_start(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
        """Start the Managed Cassandra Cluster and Associated Data Centers. Start will start the host
        virtual machine of this cluster with reserved data disk. This won't do anything on an already
        running cluster. Use Deallocate to deallocate the cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._start_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def status(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> JSON:
        """Gets the CPU, memory, and disk usage statistics for each Cassandra node in a cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "connectionErrors": [
                        {
                            "connectionState": "str",  # Optional. The kind of connection
                              error that occurred. Known values are: "Unknown", "OK",
                              "OperatorToDataCenterNetworkError", "DatacenterToDatacenterNetworkError",
                              "InternalOperatorToDataCenterCertificateError", and "InternalError".
                            "exception": "str",  # Optional. Detailed error message about
                              the failed connection.
                            "iPFrom": "str",  # Optional. The IP of host that originated
                              the failed connection.
                            "iPTo": "str",  # Optional. The IP that the connection
                              attempted to reach.
                            "port": 0  # Optional. The TCP port the connection was
                              attempted on.
                        }
                    ],
                    "dataCenters": [
                        {
                            "name": "str",  # Optional. The name of this Datacenter.
                            "nodes": [
                                {
                                    "address": "str",  # Optional. The node's IP
                                      address.
                                    "cpuUsage": 0.0,  # Optional. A float
                                      representing the current system-wide CPU utilization as a
                                      percentage.
                                    "diskFreeKB": 0,  # Optional. The amount of
                                      disk free, in kB, of the directory /var/lib/cassandra.
                                    "diskUsedKB": 0,  # Optional. The amount of
                                      disk used, in kB, of the directory /var/lib/cassandra.
                                    "hostID": "str",  # Optional. The network ID
                                      of the node.
                                    "load": "str",  # Optional. The amount of
                                      file system data in the data directory (e.g., 47.66 kB),
                                      excluding all content in the snapshots subdirectories. Because
                                      all SSTable data files are included, any data that is not cleaned
                                      up (such as TTL-expired cells or tombstones) is counted.
                                    "memoryBuffersAndCachedKB": 0,  # Optional.
                                      Memory used by kernel buffers (Buffers in /proc/meminfo) and page
                                      cache and slabs (Cached and SReclaimable in /proc/meminfo), in
                                      kB.
                                    "memoryFreeKB": 0,  # Optional. Unused memory
                                      (MemFree and SwapFree in /proc/meminfo), in kB.
                                    "memoryTotalKB": 0,  # Optional. Total
                                      installed memory (MemTotal and SwapTotal in /proc/meminfo), in
                                      kB.
                                    "memoryUsedKB": 0,  # Optional. Used memory
                                      (calculated as total - free - buffers - cache), in kB.
                                    "rack": "str",  # Optional. The rack this
                                      node is part of.
                                    "size": 0,  # Optional. List of the status of
                                      each datacenter in this cluster.
                                    "state": "str",  # Optional. The state of the
                                      node in Cassandra ring. Known values are: "Normal", "Leaving",
                                      "Joining", "Moving", and "Stopped".
                                    "status": "str",  # Optional. List of the
                                      status of each datacenter in this cluster.
                                    "timestamp": "str",  # Optional. The
                                      timestamp at which that snapshot of these usage statistics were
                                      taken.
                                    "tokens": [
                                        "str"  # Optional. List of tokens
                                          this node covers.
                                    ]
                                }
                            ],
                            "seedNodes": [
                                "str"  # Optional. A list of all seed nodes in the
                                  cluster, managed and unmanaged.
                            ]
                        }
                    ],
                    "eTag": "str",  # Optional.
                    "reaperStatus": {
                        "healthy": bool,  # Optional.
                        "repairRunIds": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        },
                        "repairSchedules": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_clusters_status_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class CassandraDataCentersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`cassandra_data_centers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """List all data centers in a particular managed Cassandra cluster.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cassandra_data_centers_list_request(
                    resource_group_name=resource_group_name,
                    cluster_name=cluster_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_group_name: str, cluster_name: str, data_center_name: str, **kwargs: Any) -> JSON:
        """Get the properties of a managed Cassandra data center.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_cassandra_data_centers_get_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            data_center_name=data_center_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, cluster_name: str, data_center_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_cassandra_data_centers_delete_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            data_center_name=data_center_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, cluster_name: str, data_center_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Delete a managed Cassandra data center.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                data_center_name=data_center_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _create_update_initial(
        self, resource_group_name: str, cluster_name: str, data_center_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_cassandra_data_centers_create_update_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            data_center_name=data_center_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_create_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        data_center_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a managed Cassandra data center. When updating, overwrite all properties. To
        update only some properties, use PATCH.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :param body: Parameters specifying the managed Cassandra data center. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        data_center_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a managed Cassandra data center. When updating, overwrite all properties. To
        update only some properties, use PATCH.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :param body: Parameters specifying the managed Cassandra data center. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_update(
        self, resource_group_name: str, cluster_name: str, data_center_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Create or update a managed Cassandra data center. When updating, overwrite all properties. To
        update only some properties, use PATCH.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :param body: Parameters specifying the managed Cassandra data center. Is either a model type or
         a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                data_center_name=data_center_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _update_initial(
        self, resource_group_name: str, cluster_name: str, data_center_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_cassandra_data_centers_update_request(
            resource_group_name=resource_group_name,
            cluster_name=cluster_name,
            data_center_name=data_center_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        data_center_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update some of the properties of a managed Cassandra data center.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :param body: Parameters to provide for specifying the managed Cassandra data center. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_update(
        self,
        resource_group_name: str,
        cluster_name: str,
        data_center_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update some of the properties of a managed Cassandra data center.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :param body: Parameters to provide for specifying the managed Cassandra data center. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_update(
        self, resource_group_name: str, cluster_name: str, data_center_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Update some of the properties of a managed Cassandra data center.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param cluster_name: Managed Cassandra cluster name. Required.
        :type cluster_name: str
        :param data_center_name: Data center name in a managed Cassandra cluster. Required.
        :type data_center_name: str
        :param body: Parameters to provide for specifying the managed Cassandra data center. Is either
         a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "authenticationMethodLdapProperties": {
                            "searchBaseDistinguishedName": "str",  # Optional.
                              Distinguished name of the object to start the recursive search of users
                              from.
                            "searchFilterTemplate": "str",  # Optional. Template to use
                              for searching. Defaults to (cn=%s) where %s will be replaced by the
                              username used to login.
                            "serverCertificates": [
                                {
                                    "pem": "str"  # Optional. PEM formatted
                                      public key.
                                }
                            ],
                            "serverHostname": "str",  # Optional. Hostname of the LDAP
                              server.
                            "serverPort": 0,  # Optional. Port of the LDAP server.
                            "serviceUserDistinguishedName": "str",  # Optional.
                              Distinguished name of the look up user account, who can look up user
                              details on authentication.
                            "serviceUserPassword": "str"  # Optional. Password of the
                              look up user.
                        },
                        "availabilityZone": bool,  # Optional. If the data center has
                          Availability Zone feature, apply it to the Virtual Machine ScaleSet that host
                          the cassandra data center virtual machines.
                        "backupStorageCustomerKeyUri": "str",  # Optional. Indicates the Key
                          Uri of the customer key to use for encryption of the backup storage account.
                        "base64EncodedCassandraYamlFragment": "str",  # Optional. A fragment
                          of a cassandra.yaml configuration file to be included in the cassandra.yaml
                          for all nodes in this data center. The fragment should be Base64 encoded, and
                          only a subset of keys are allowed.
                        "dataCenterLocation": "str",  # Optional. The region this data center
                          should be created in.
                        "delegatedSubnetId": "str",  # Optional. Resource id of a subnet the
                          nodes in this data center should have their network interfaces connected to.
                          The subnet must be in the same region specified in 'dataCenterLocation' and
                          must be able to route to the subnet specified in the cluster's
                          'delegatedManagementSubnetId' property. This resource id will be of the form
                          '/subscriptions/:code:`<subscription id>`/resourceGroups/:code:`<resource
                          group>`/providers/Microsoft.Network/virtualNetworks/:code:`<virtual
                          network>`/subnets/:code:`<subnet>`'.
                        "diskCapacity": 0,  # Optional. Number of disk used for data centers.
                          Default value is 4.
                        "diskSku": "str",  # Optional. Disk SKU used for data centers.
                          Default value is P30.
                        "managedDiskCustomerKeyUri": "str",  # Optional. Key uri to use for
                          encryption of managed disks. Ensure the system assigned identity of the
                          cluster has been assigned appropriate permissions(key get/wrap/unwrap
                          permissions) on the key.
                        "nodeCount": 0,  # Optional. The number of nodes the data center
                          should have. This is the desired number. After it is set, it may take some
                          time for the data center to be scaled to match. To monitor the number of
                          nodes and their status, use the fetchNodeStatus method on the cluster.
                        "provisioningState": "str",  # Optional. The status of the resource
                          at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "seedNodes": [
                            {
                                "ipAddress": "str"  # Optional. IP address of this
                                  seed node.
                            }
                        ],
                        "sku": "str"  # Optional. Virtual Machine SKU used for data centers.
                          Default value is Standard_DS14_v2.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                cluster_name=cluster_name,
                data_center_name=data_center_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class NotebookWorkspacesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`notebook_workspaces` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_database_account(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Gets the notebook workspace resources of an existing Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "notebookServerEndpoint": "str",  # Optional. Specifies the endpoint
                          of Notebook server.
                        "status": "str"  # Optional. Status of the notebook workspace.
                          Possible values are: Creating, Online, Deleting, Failed, Updating.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_notebook_workspaces_list_by_database_account_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the notebook workspace for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "notebookServerEndpoint": "str",  # Optional. Specifies the endpoint
                          of Notebook server.
                        "status": "str"  # Optional. Status of the notebook workspace.
                          Possible values are: Creating, Online, Deleting, Failed, Updating.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_notebook_workspaces_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            notebook_workspace_name=notebook_workspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        account_name: str,
        notebook_workspace_name: str,
        notebook_create_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(notebook_create_update_parameters, (IO, bytes)):
            _content = notebook_create_update_parameters
        else:
            _json = notebook_create_update_parameters

        request = build_notebook_workspaces_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            notebook_workspace_name=notebook_workspace_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        notebook_workspace_name: str,
        notebook_create_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates the notebook workspace for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :param notebook_create_update_parameters: The notebook workspace to create for the current
         database account. Required.
        :type notebook_create_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                notebook_create_update_parameters = {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "type": "str"  # Optional. The type of Azure resource.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "notebookServerEndpoint": "str",  # Optional. Specifies the endpoint
                          of Notebook server.
                        "status": "str"  # Optional. Status of the notebook workspace.
                          Possible values are: Creating, Online, Deleting, Failed, Updating.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        notebook_workspace_name: str,
        notebook_create_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates the notebook workspace for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :param notebook_create_update_parameters: The notebook workspace to create for the current
         database account. Required.
        :type notebook_create_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "notebookServerEndpoint": "str",  # Optional. Specifies the endpoint
                          of Notebook server.
                        "status": "str"  # Optional. Status of the notebook workspace.
                          Possible values are: Creating, Online, Deleting, Failed, Updating.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        notebook_workspace_name: str,
        notebook_create_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates the notebook workspace for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :param notebook_create_update_parameters: The notebook workspace to create for the current
         database account. Is either a model type or a IO type. Required.
        :type notebook_create_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "notebookServerEndpoint": "str",  # Optional. Specifies the endpoint
                          of Notebook server.
                        "status": "str"  # Optional. Status of the notebook workspace.
                          Possible values are: Creating, Online, Deleting, Failed, Updating.
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_or_update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                notebook_workspace_name=notebook_workspace_name,
                notebook_create_update_parameters=notebook_create_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_notebook_workspaces_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            notebook_workspace_name=notebook_workspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes the notebook workspace for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                notebook_workspace_name=notebook_workspace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def list_connection_info(
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> JSON:
        """Retrieves the connection info for the notebook workspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Optional. Specifies auth token used for connecting to
                      Notebook server (uses token-based auth).
                    "notebookServerEndpoint": "str"  # Optional. Specifies the endpoint of
                      Notebook server.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_notebook_workspaces_list_connection_info_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            notebook_workspace_name=notebook_workspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _regenerate_auth_token_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_notebook_workspaces_regenerate_auth_token_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            notebook_workspace_name=notebook_workspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_regenerate_auth_token(
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Regenerates the auth token for the notebook workspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._regenerate_auth_token_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                notebook_workspace_name=notebook_workspace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _start_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_notebook_workspaces_start_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            notebook_workspace_name=notebook_workspace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_start(
        self, resource_group_name: str, account_name: str, notebook_workspace_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Starts the notebook workspace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param notebook_workspace_name: The name of the notebook workspace resource. "default"
         Required.
        :type notebook_workspace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._start_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                notebook_workspace_name=notebook_workspace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class PrivateEndpointConnectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`private_endpoint_connections` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_database_account(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """List all private endpoint connections on a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. Group id of the private endpoint.
                        "privateEndpoint": {
                            "id": "str"  # Optional. Resource id of the private endpoint.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. Any action that is
                              required beyond basic workflow (approve/ reject/ disconnect).
                            "description": "str",  # Optional. The private link service
                              connection description.
                            "status": "str"  # Optional. The private link service
                              connection status.
                        },
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          private endpoint.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_private_endpoint_connections_list_by_database_account_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(
        self, resource_group_name: str, account_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> JSON:
        """Gets a private endpoint connection.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. Group id of the private endpoint.
                        "privateEndpoint": {
                            "id": "str"  # Optional. Resource id of the private endpoint.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. Any action that is
                              required beyond basic workflow (approve/ reject/ disconnect).
                            "description": "str",  # Optional. The private link service
                              connection description.
                            "status": "str"  # Optional. The private link service
                              connection status.
                        },
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          private endpoint.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_private_endpoint_connections_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _create_or_update_initial(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_private_endpoint_connections_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Approve or reject a private endpoint connection with a given name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param parameters: Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. Group id of the private endpoint.
                        "privateEndpoint": {
                            "id": "str"  # Optional. Resource id of the private endpoint.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. Any action that is
                              required beyond basic workflow (approve/ reject/ disconnect).
                            "description": "str",  # Optional. The private link service
                              connection description.
                            "status": "str"  # Optional. The private link service
                              connection status.
                        },
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          private endpoint.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. Group id of the private endpoint.
                        "privateEndpoint": {
                            "id": "str"  # Optional. Resource id of the private endpoint.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. Any action that is
                              required beyond basic workflow (approve/ reject/ disconnect).
                            "description": "str",  # Optional. The private link service
                              connection description.
                            "status": "str"  # Optional. The private link service
                              connection status.
                        },
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          private endpoint.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Approve or reject a private endpoint connection with a given name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param parameters: Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. Group id of the private endpoint.
                        "privateEndpoint": {
                            "id": "str"  # Optional. Resource id of the private endpoint.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. Any action that is
                              required beyond basic workflow (approve/ reject/ disconnect).
                            "description": "str",  # Optional. The private link service
                              connection description.
                            "status": "str"  # Optional. The private link service
                              connection status.
                        },
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          private endpoint.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Approve or reject a private endpoint connection with a given name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param parameters: Is either a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. Group id of the private endpoint.
                        "privateEndpoint": {
                            "id": "str"  # Optional. Resource id of the private endpoint.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. Any action that is
                              required beyond basic workflow (approve/ reject/ disconnect).
                            "description": "str",  # Optional. The private link service
                              connection description.
                            "status": "str"  # Optional. The private link service
                              connection status.
                        },
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          private endpoint.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_or_update_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_private_endpoint_connections_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, account_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes a private endpoint connection with a given name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)


class PrivateLinkResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`private_link_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_database_account(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Gets the private link resources that need to be created for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "groupId": "str",  # Optional. The private link resource group id.
                        "requiredMembers": [
                            "str"  # Optional. The private link resource required member
                              names.
                        ],
                        "requiredZoneNames": [
                            "str"  # Optional. The private link resource required zone
                              names.
                        ]
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_private_link_resources_list_by_database_account_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, resource_group_name: str, account_name: str, group_name: str, **kwargs: Any) -> JSON:
        """Gets the private link resources that need to be created for a Cosmos DB account.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param group_name: The name of the private link resource. Required.
        :type group_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": {
                        "groupId": "str",  # Optional. The private link resource group id.
                        "requiredMembers": [
                            "str"  # Optional. The private link resource required member
                              names.
                        ],
                        "requiredZoneNames": [
                            "str"  # Optional. The private link resource required zone
                              names.
                        ]
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_private_link_resources_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            group_name=group_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class RestorableDatabaseAccountsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_database_accounts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_location(self, location: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists all the restorable Azure Cosmos DB database accounts available under the subscription and
        in a region.  This call requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "accountName": "str",  # Optional. The name of the global database
                          account.
                        "apiType": "str",  # Optional. The API type of the restorable
                          database account. Known values are: "MongoDB", "Gremlin", "Cassandra",
                          "Table", "Sql", and "GremlinV2".
                        "creationTime": "2020-02-20 00:00:00",  # Optional. The creation time
                          of the restorable database account (ISO-8601 format).
                        "deletionTime": "2020-02-20 00:00:00",  # Optional. The time at which
                          the restorable database account has been deleted (ISO-8601 format).
                        "oldestRestorableTime": "2020-02-20 00:00:00",  # Optional. The least
                          recent time at which the database account can be restored to (ISO-8601
                          format).
                        "restorableLocations": [
                            {
                                "creationTime": "2020-02-20 00:00:00",  # Optional.
                                  The creation time of the regional restorable database account
                                  (ISO-8601 format).
                                "deletionTime": "2020-02-20 00:00:00",  # Optional.
                                  The time at which the regional restorable database account has been
                                  deleted (ISO-8601 format).
                                "locationName": "str",  # Optional. The location of
                                  the regional restorable account.
                                "regionalDatabaseAccountInstanceId": "str"  #
                                  Optional. The instance id of the regional restorable account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_database_accounts_list_by_location_request(
                    location=location,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists all the restorable Azure Cosmos DB database accounts available under the subscription.
        This call requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read' permission.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "accountName": "str",  # Optional. The name of the global database
                          account.
                        "apiType": "str",  # Optional. The API type of the restorable
                          database account. Known values are: "MongoDB", "Gremlin", "Cassandra",
                          "Table", "Sql", and "GremlinV2".
                        "creationTime": "2020-02-20 00:00:00",  # Optional. The creation time
                          of the restorable database account (ISO-8601 format).
                        "deletionTime": "2020-02-20 00:00:00",  # Optional. The time at which
                          the restorable database account has been deleted (ISO-8601 format).
                        "oldestRestorableTime": "2020-02-20 00:00:00",  # Optional. The least
                          recent time at which the database account can be restored to (ISO-8601
                          format).
                        "restorableLocations": [
                            {
                                "creationTime": "2020-02-20 00:00:00",  # Optional.
                                  The creation time of the regional restorable database account
                                  (ISO-8601 format).
                                "deletionTime": "2020-02-20 00:00:00",  # Optional.
                                  The time at which the regional restorable database account has been
                                  deleted (ISO-8601 format).
                                "locationName": "str",  # Optional. The location of
                                  the regional restorable account.
                                "regionalDatabaseAccountInstanceId": "str"  #
                                  Optional. The instance id of the regional restorable account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_database_accounts_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_by_location(self, location: str, instance_id: str, **kwargs: Any) -> JSON:
        """Retrieves the properties of an existing Azure Cosmos DB restorable database account.  This call
        requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read/*' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "location": "str",  # Optional. The location of the resource group to which
                      the resource belongs.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "accountName": "str",  # Optional. The name of the global database
                          account.
                        "apiType": "str",  # Optional. The API type of the restorable
                          database account. Known values are: "MongoDB", "Gremlin", "Cassandra",
                          "Table", "Sql", and "GremlinV2".
                        "creationTime": "2020-02-20 00:00:00",  # Optional. The creation time
                          of the restorable database account (ISO-8601 format).
                        "deletionTime": "2020-02-20 00:00:00",  # Optional. The time at which
                          the restorable database account has been deleted (ISO-8601 format).
                        "oldestRestorableTime": "2020-02-20 00:00:00",  # Optional. The least
                          recent time at which the database account can be restored to (ISO-8601
                          format).
                        "restorableLocations": [
                            {
                                "creationTime": "2020-02-20 00:00:00",  # Optional.
                                  The creation time of the regional restorable database account
                                  (ISO-8601 format).
                                "deletionTime": "2020-02-20 00:00:00",  # Optional.
                                  The time at which the regional restorable database account has been
                                  deleted (ISO-8601 format).
                                "locationName": "str",  # Optional. The location of
                                  the regional restorable account.
                                "regionalDatabaseAccountInstanceId": "str"  #
                                  Optional. The instance id of the regional restorable account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_restorable_database_accounts_get_by_location_request(
            location=location,
            instance_id=instance_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class RestorableSqlDatabasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_sql_databases` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, location: str, instance_id: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB SQL databases under the
        restorable account.  This helps in scenario where database was accidentally deleted to get the
        deletion time.  This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "database": {
                                "id": "str",  # Name of the Cosmos DB SQL database.
                                  Required.
                                "_colls": "str",  # Optional. A system generated
                                  property that specified the addressable path of the collections
                                  resource.
                                "_etag": "str",  # Optional. A system generated
                                  property representing the resource etag required for optimistic
                                  concurrency control.
                                "_rid": "str",  # Optional. A system generated
                                  property. A unique identifier.
                                "_self": "str",  # Optional. A system generated
                                  property that specifies the addressable path of the database
                                  resource.
                                "_ts": 0.0,  # Optional. A system generated property
                                  that denotes the last updated timestamp of the resource.
                                "_users": "str",  # Optional. A system generated
                                  property that specifies the addressable path of the users resource.
                                "createMode": "Default",  # Optional. Default value
                                  is "Default". Enum to indicate the mode of resource creation. Known
                                  values are: "Default" and "Restore".
                                "restoreParameters": {
                                    "restoreSource": "str",  # Optional. The id
                                      of the restorable database account from which the restore has to
                                      be initiated. For example:
                                      /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                    "restoreTimestampInUtc": "2020-02-20
                                      00:00:00"  # Optional. Time to which the account has to be
                                      restored (ISO-8601 format).
                                }
                            },
                            "eventTimestamp": "str",  # Optional. The time when this
                              database event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this database event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of the SQL database.
                            "ownerResourceId": "str"  # Optional. The resource ID of the
                              SQL database.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_sql_databases_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableSqlContainersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_sql_containers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restorable_sql_database_rid: Optional[str] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB SQL containers under a
        specific database.  This helps in scenario where container was accidentally deleted.  This API
        requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restorable_sql_database_rid: The resource ID of the SQL database. Default value is
         None.
        :paramtype restorable_sql_database_rid: str
        :keyword start_time: Restorable Sql containers event feed start time. Default value is None.
        :paramtype start_time: str
        :keyword end_time: Restorable Sql containers event feed end time. Default value is None.
        :paramtype end_time: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "container": {
                                "id": "str",  # Name of the Cosmos DB SQL container.
                                  Required.
                                "_etag": "str",  # Optional. A system generated
                                  property representing the resource etag required for optimistic
                                  concurrency control.
                                "_rid": "str",  # Optional. A system generated
                                  property. A unique identifier.
                                "_self": "str",  # Optional. A system generated
                                  property that specifies the addressable path of the container
                                  resource.
                                "_ts": 0.0,  # Optional. A system generated property
                                  that denotes the last updated timestamp of the resource.
                                "analyticalStorageTtl": 0,  # Optional. Analytical
                                  TTL.
                                "clientEncryptionPolicy": {
                                    "includedPaths": [
                                        {
                                            "clientEncryptionKeyId":
                                              "str",  # The identifier of the Client Encryption Key to
                                              be used to encrypt the path. Required.
                                            "encryptionAlgorithm": "str",
                                              # The encryption algorithm which will be used. Eg -
                                              AEAD_AES_256_CBC_HMAC_SHA256. Required.
                                            "encryptionType": "str",  #
                                              The type of encryption to be performed. Eg -
                                              Deterministic, Randomized. Required.
                                            "path": "str"  # Path that
                                              needs to be encrypted. Required.
                                        }
                                    ],
                                    "policyFormatVersion": 1  # Optional. Default
                                      value is 1. Version of the client encryption policy definition.
                                      Please note, user passed value is ignored. Default policy version
                                      is 1.
                                },
                                "conflictResolutionPolicy": {
                                    "conflictResolutionPath": "str",  # Optional.
                                      The conflict resolution path in the case of LastWriterWins mode.
                                    "conflictResolutionProcedure": "str",  #
                                      Optional. The procedure to resolve conflicts in the case of
                                      custom mode.
                                    "mode": "LastWriterWins"  # Optional. Default
                                      value is "LastWriterWins". Indicates the conflict resolution
                                      mode. Known values are: "LastWriterWins" and "Custom".
                                },
                                "createMode": "Default",  # Optional. Default value
                                  is "Default". Enum to indicate the mode of resource creation. Known
                                  values are: "Default" and "Restore".
                                "defaultTtl": 0,  # Optional. Default time to live.
                                "indexingPolicy": {
                                    "automatic": bool,  # Optional. Indicates if
                                      the indexing policy is automatic.
                                    "compositeIndexes": [
                                        [
                                            {
                                                "order": "str",  #
                                                  Optional. Sort order for composite paths. Known
                                                  values are: "ascending" and "descending".
                                                "path": "str"  #
                                                  Optional. The path for which the indexing behavior
                                                  applies to. Index paths typically start with root and
                                                  end with wildcard (/path/*).
                                            }
                                        ]
                                    ],
                                    "excludedPaths": [
                                        {
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ],
                                    "includedPaths": [
                                        {
                                            "indexes": [
                                                {
                                                    "dataType":
                                                      "String",  # Optional. Default value is "String".
                                                      The datatype for which the indexing behavior is
                                                      applied to. Known values are: "String", "Number",
                                                      "Point", "Polygon", "LineString", and
                                                      "MultiPolygon".
                                                    "kind":
                                                      "Hash",  # Optional. Default value is "Hash".
                                                      Indicates the type of index. Known values are:
                                                      "Hash", "Range", and "Spatial".
                                                    "precision":
                                                      0  # Optional. The precision of the index. -1 is
                                                      maximum precision.
                                                }
                                            ],
                                            "path": "str"  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                        }
                                    ],
                                    "indexingMode": "consistent",  # Optional.
                                      Default value is "consistent". Indicates the indexing mode. Known
                                      values are: "consistent", "lazy", and "none".
                                    "spatialIndexes": [
                                        {
                                            "path": "str",  # Optional.
                                              The path for which the indexing behavior applies to.
                                              Index paths typically start with root and end with
                                              wildcard (/path/*).
                                            "types": [
                                                "str"  # Optional.
                                                  List of path's spatial type.
                                            ]
                                        }
                                    ]
                                },
                                "partitionKey": {
                                    "kind": "Hash",  # Optional. Default value is
                                      "Hash". Indicates the kind of algorithm used for partitioning.
                                      For MultiHash, multiple partition keys (upto three maximum) are
                                      supported for container create. Known values are: "Hash",
                                      "Range", and "MultiHash".
                                    "paths": [
                                        "str"  # Optional. List of paths
                                          using which data within the container can be partitioned.
                                    ],
                                    "systemKey": bool,  # Optional. Indicates if
                                      the container is using a system generated partition key.
                                    "version": 0  # Optional. Indicates the
                                      version of the partition key definition.
                                },
                                "restoreParameters": {
                                    "restoreSource": "str",  # Optional. The id
                                      of the restorable database account from which the restore has to
                                      be initiated. For example:
                                      /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}.
                                    "restoreTimestampInUtc": "2020-02-20
                                      00:00:00"  # Optional. Time to which the account has to be
                                      restored (ISO-8601 format).
                                },
                                "uniqueKeyPolicy": {
                                    "uniqueKeys": [
                                        {
                                            "paths": [
                                                "str"  # Optional.
                                                  List of paths must be unique for each document in the
                                                  Azure Cosmos DB service.
                                            ]
                                        }
                                    ]
                                }
                            },
                            "eventTimestamp": "str",  # Optional. The when this container
                              event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this container event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of this SQL
                              container.
                            "ownerResourceId": "str"  # Optional. The resource ID of this
                              SQL container.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_sql_containers_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restorable_sql_database_rid=restorable_sql_database_rid,
                    start_time=start_time,
                    end_time=end_time,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableSqlResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_sql_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restore_location: Optional[str] = None,
        restore_timestamp_in_utc: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Return a list of database and container combo that exist on the account at the given timestamp
        and location. This helps in scenarios to validate what resources exist at given timestamp and
        location. This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restore_location: The location where the restorable resources are located. Default
         value is None.
        :paramtype restore_location: str
        :keyword restore_timestamp_in_utc: The timestamp when the restorable resources existed. Default
         value is None.
        :paramtype restore_timestamp_in_utc: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "collectionNames": [
                        "str"  # Optional. The names of the collections available for
                          restore.
                    ],
                    "databaseName": "str",  # Optional. The name of the database available for
                      restore.
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_sql_resources_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restore_location=restore_location,
                    restore_timestamp_in_utc=restore_timestamp_in_utc,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableMongodbDatabasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_mongodb_databases` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, location: str, instance_id: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB MongoDB databases under
        the restorable account.  This helps in scenario where database was accidentally deleted to get
        the deletion time.  This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "eventTimestamp": "str",  # Optional. The time when this
                              database event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this database event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of this MongoDB
                              database.
                            "ownerResourceId": "str"  # Optional. The resource ID of this
                              MongoDB database.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_mongodb_databases_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableMongodbCollectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_mongodb_collections` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restorable_mongodb_database_rid: Optional[str] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB MongoDB collections under
        a specific database.  This helps in scenario where container was accidentally deleted.  This
        API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restorable_mongodb_database_rid: The resource ID of the MongoDB database. Default
         value is None.
        :paramtype restorable_mongodb_database_rid: str
        :keyword start_time: Restorable MongoDB collections event feed start time. Default value is
         None.
        :paramtype start_time: str
        :keyword end_time: Restorable MongoDB collections event feed end time. Default value is None.
        :paramtype end_time: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "eventTimestamp": "str",  # Optional. The time when this
                              collection event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this collection event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of this MongoDB
                              collection.
                            "ownerResourceId": "str"  # Optional. The resource ID of this
                              MongoDB collection.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_mongodb_collections_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restorable_mongodb_database_rid=restorable_mongodb_database_rid,
                    start_time=start_time,
                    end_time=end_time,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableMongodbResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_mongodb_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restore_location: Optional[str] = None,
        restore_timestamp_in_utc: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Return a list of database and collection combo that exist on the account at the given timestamp
        and location. This helps in scenarios to validate what resources exist at given timestamp and
        location. This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restore_location: The location where the restorable resources are located. Default
         value is None.
        :paramtype restore_location: str
        :keyword restore_timestamp_in_utc: The timestamp when the restorable resources existed. Default
         value is None.
        :paramtype restore_timestamp_in_utc: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "collectionNames": [
                        "str"  # Optional. The names of the collections available for
                          restore.
                    ],
                    "databaseName": "str",  # Optional. The name of the database available for
                      restore.
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_mongodb_resources_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restore_location=restore_location,
                    restore_timestamp_in_utc=restore_timestamp_in_utc,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableGremlinDatabasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_gremlin_databases` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, location: str, instance_id: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB Gremlin databases under
        the restorable account. This helps in scenario where database was accidentally deleted to get
        the deletion time. This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "eventTimestamp": "str",  # Optional. The time when this
                              database event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this database event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of this Gremlin
                              database.
                            "ownerResourceId": "str"  # Optional. The resource ID of this
                              Gremlin database.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_gremlin_databases_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableGremlinGraphsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_gremlin_graphs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restorable_gremlin_database_rid: Optional[str] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB Gremlin graphs under a
        specific database. This helps in scenario where container was accidentally deleted. This API
        requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restorable_gremlin_database_rid: The resource ID of the Gremlin database. Default
         value is None.
        :paramtype restorable_gremlin_database_rid: str
        :keyword start_time: Restorable Gremlin graphs event feed start time. Default value is None.
        :paramtype start_time: str
        :keyword end_time: Restorable Gremlin graphs event feed end time. Default value is None.
        :paramtype end_time: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "eventTimestamp": "str",  # Optional. The time when this
                              graph event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this graph event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of this Gremlin
                              graph.
                            "ownerResourceId": "str"  # Optional. The resource ID of this
                              Gremlin graph.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_gremlin_graphs_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restorable_gremlin_database_rid=restorable_gremlin_database_rid,
                    start_time=start_time,
                    end_time=end_time,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableGremlinResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_gremlin_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restore_location: Optional[str] = None,
        restore_timestamp_in_utc: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Return a list of gremlin database and graphs combo that exist on the account at the given
        timestamp and location. This helps in scenarios to validate what resources exist at given
        timestamp and location. This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restore_location: The location where the restorable resources are located. Default
         value is None.
        :paramtype restore_location: str
        :keyword restore_timestamp_in_utc: The timestamp when the restorable resources existed. Default
         value is None.
        :paramtype restore_timestamp_in_utc: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "databaseName": "str",  # Optional. The name of the gremlin database
                      available for restore.
                    "graphNames": [
                        "str"  # Optional. The names of the graphs available for restore.
                    ],
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_gremlin_resources_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restore_location=restore_location,
                    restore_timestamp_in_utc=restore_timestamp_in_utc,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableTablesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_tables` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Show the event feed of all mutations done on all the Azure Cosmos DB Tables. This helps in
        scenario where table was accidentally deleted. This API requires
        'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword start_time: Restorable Tables event feed start time. Default value is None.
        :paramtype start_time: str
        :keyword end_time: Restorable Tables event feed end time. Default value is None.
        :paramtype end_time: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource Identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the ARM resource.
                    "properties": {
                        "resource": {
                            "_rid": "str",  # Optional. A system generated property. A
                              unique identifier.
                            "eventTimestamp": "str",  # Optional. The time when this
                              table event happened.
                            "operationType": "str",  # Optional. The operation type of
                              this table event. Known values are: "Create", "Replace", "Delete",
                              "Recreate", and "SystemOperation".
                            "ownerId": "str",  # Optional. The name of this Table.
                            "ownerResourceId": "str"  # Optional. The resource ID of this
                              Table.
                        }
                    },
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_tables_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    start_time=start_time,
                    end_time=end_time,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class RestorableTableResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`restorable_table_resources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        location: str,
        instance_id: str,
        *,
        restore_location: Optional[str] = None,
        restore_timestamp_in_utc: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Return a list of tables that exist on the account at the given timestamp and location. This
        helps in scenarios to validate what resources exist at given timestamp and location. This API
        requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.

        :param location: Cosmos DB region, with spaces between words and each word capitalized.
         Required.
        :type location: str
        :param instance_id: The instanceId GUID of a restorable database account. Required.
        :type instance_id: str
        :keyword restore_location: The location where the restorable resources are located. Default
         value is None.
        :paramtype restore_location: str
        :keyword restore_timestamp_in_utc: The timestamp when the restorable resources existed. Default
         value is None.
        :paramtype restore_timestamp_in_utc: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the ARM resource.
                    "name": "str",  # Optional. The name of the Table.
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_restorable_table_resources_list_request(
                    location=location,
                    instance_id=instance_id,
                    subscription_id=self._config.subscription_id,
                    restore_location=restore_location,
                    restore_timestamp_in_utc=restore_timestamp_in_utc,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ServiceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.cosmosdb.aio.CosmosDBManagementClient`'s
        :attr:`service` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, account_name: str, **kwargs: Any) -> AsyncIterable[JSON]:
        """Gets the status of service.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "serviceType":

                # JSON input template for discriminator value "DataTransfer":
                service_resource_properties = {
                    "serviceType": "DataTransfer",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "GraphAPICompute":
                service_resource_properties = {
                    "serviceType": "GraphAPICompute",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "graphApiComputeEndpoint": "str",  # Optional. GraphAPICompute endpoint for
                      the service.
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "graphApiComputeEndpoint": "str",  # Optional. The regional
                              endpoint for GraphAPICompute.
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "MaterializedViewsBuilder":
                service_resource_properties = {
                    "serviceType": "MaterializedViewsBuilder",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "SqlDedicatedGateway":
                service_resource_properties = {
                    "serviceType": "SqlDedicatedGateway",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "sqlDedicatedGatewayEndpoint": "str",  # Optional. The
                              regional endpoint for SqlDedicatedGateway.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "sqlDedicatedGatewayEndpoint": "str",  # Optional. SqlDedicatedGateway
                      endpoint for the service.
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": service_resource_properties,
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_service_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    async def _create_initial(
        self,
        resource_group_name: str,
        account_name: str,
        service_name: str,
        create_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_update_parameters, (IO, bytes)):
            _content = create_update_parameters
        else:
            _json = create_update_parameters

        request = build_service_create_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            service_name=service_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        account_name: str,
        service_name: str,
        create_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates a service.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param service_name: Cosmos DB service name. Required.
        :type service_name: str
        :param create_update_parameters: The Service resource parameters. Required.
        :type create_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_update_parameters = {
                    "properties": {
                        "instanceCount": 0,  # Optional. Instance count for the service.
                        "instanceSize": "str",  # Optional. Instance type for the service.
                          Known values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                        "serviceType": "str"  # Optional. ServiceType for the service. Known
                          values are: "SqlDedicatedGateway", "DataTransfer", "GraphAPICompute", and
                          "MaterializedViewsBuilder".
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "serviceType":

                # JSON input template for discriminator value "DataTransfer":
                service_resource_properties = {
                    "serviceType": "DataTransfer",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "GraphAPICompute":
                service_resource_properties = {
                    "serviceType": "GraphAPICompute",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "graphApiComputeEndpoint": "str",  # Optional. GraphAPICompute endpoint for
                      the service.
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "graphApiComputeEndpoint": "str",  # Optional. The regional
                              endpoint for GraphAPICompute.
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "MaterializedViewsBuilder":
                service_resource_properties = {
                    "serviceType": "MaterializedViewsBuilder",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "SqlDedicatedGateway":
                service_resource_properties = {
                    "serviceType": "SqlDedicatedGateway",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "sqlDedicatedGatewayEndpoint": "str",  # Optional. The
                              regional endpoint for SqlDedicatedGateway.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "sqlDedicatedGatewayEndpoint": "str",  # Optional. SqlDedicatedGateway
                      endpoint for the service.
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": service_resource_properties,
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @overload
    async def begin_create(
        self,
        resource_group_name: str,
        account_name: str,
        service_name: str,
        create_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates a service.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param service_name: Cosmos DB service name. Required.
        :type service_name: str
        :param create_update_parameters: The Service resource parameters. Required.
        :type create_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "serviceType":

                # JSON input template for discriminator value "DataTransfer":
                service_resource_properties = {
                    "serviceType": "DataTransfer",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "GraphAPICompute":
                service_resource_properties = {
                    "serviceType": "GraphAPICompute",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "graphApiComputeEndpoint": "str",  # Optional. GraphAPICompute endpoint for
                      the service.
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "graphApiComputeEndpoint": "str",  # Optional. The regional
                              endpoint for GraphAPICompute.
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "MaterializedViewsBuilder":
                service_resource_properties = {
                    "serviceType": "MaterializedViewsBuilder",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "SqlDedicatedGateway":
                service_resource_properties = {
                    "serviceType": "SqlDedicatedGateway",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "sqlDedicatedGatewayEndpoint": "str",  # Optional. The
                              regional endpoint for SqlDedicatedGateway.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "sqlDedicatedGatewayEndpoint": "str",  # Optional. SqlDedicatedGateway
                      endpoint for the service.
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": service_resource_properties,
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """

    @distributed_trace_async
    async def begin_create(
        self,
        resource_group_name: str,
        account_name: str,
        service_name: str,
        create_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> AsyncLROPoller[JSON]:
        """Creates a service.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param service_name: Cosmos DB service name. Required.
        :type service_name: str
        :param create_update_parameters: The Service resource parameters. Is either a model type or a
         IO type. Required.
        :type create_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns JSON object
        :rtype: ~azure.core.polling.AsyncLROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "serviceType":

                # JSON input template for discriminator value "DataTransfer":
                service_resource_properties = {
                    "serviceType": "DataTransfer",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "GraphAPICompute":
                service_resource_properties = {
                    "serviceType": "GraphAPICompute",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "graphApiComputeEndpoint": "str",  # Optional. GraphAPICompute endpoint for
                      the service.
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "graphApiComputeEndpoint": "str",  # Optional. The regional
                              endpoint for GraphAPICompute.
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "MaterializedViewsBuilder":
                service_resource_properties = {
                    "serviceType": "MaterializedViewsBuilder",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "SqlDedicatedGateway":
                service_resource_properties = {
                    "serviceType": "SqlDedicatedGateway",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "sqlDedicatedGatewayEndpoint": "str",  # Optional. The
                              regional endpoint for SqlDedicatedGateway.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "sqlDedicatedGatewayEndpoint": "str",  # Optional. SqlDedicatedGateway
                      endpoint for the service.
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": service_resource_properties,
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                service_name=service_name,
                create_update_parameters=create_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace_async
    async def get(self, resource_group_name: str, account_name: str, service_name: str, **kwargs: Any) -> JSON:
        """Gets the status of service.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param service_name: Cosmos DB service name. Required.
        :type service_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "serviceType":

                # JSON input template for discriminator value "DataTransfer":
                service_resource_properties = {
                    "serviceType": "DataTransfer",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "GraphAPICompute":
                service_resource_properties = {
                    "serviceType": "GraphAPICompute",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "graphApiComputeEndpoint": "str",  # Optional. GraphAPICompute endpoint for
                      the service.
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "graphApiComputeEndpoint": "str",  # Optional. The regional
                              endpoint for GraphAPICompute.
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "MaterializedViewsBuilder":
                service_resource_properties = {
                    "serviceType": "MaterializedViewsBuilder",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # JSON input template for discriminator value "SqlDedicatedGateway":
                service_resource_properties = {
                    "serviceType": "SqlDedicatedGateway",
                    "creationTime": "2020-02-20 00:00:00",  # Optional. Time of the last state
                      change (ISO-8601 format).
                    "instanceCount": 0,  # Optional. Instance count for the service.
                    "instanceSize": "str",  # Optional. Instance type for the service. Known
                      values are: "Cosmos.D4s", "Cosmos.D8s", and "Cosmos.D16s".
                    "locations": [
                        {
                            "location": "str",  # Optional. The location name.
                            "name": "str",  # Optional. The regional service name.
                            "sqlDedicatedGatewayEndpoint": "str",  # Optional. The
                              regional endpoint for SqlDedicatedGateway.
                            "status": "str"  # Optional. Describes the status of a
                              service. Known values are: "Creating", "Running", "Updating", "Deleting",
                              "Error", and "Stopped".
                        }
                    ],
                    "sqlDedicatedGatewayEndpoint": "str",  # Optional. SqlDedicatedGateway
                      endpoint for the service.
                    "status": "str"  # Optional. Describes the status of a service. Known values
                      are: "Creating", "Running", "Updating", "Deleting", "Error", and "Stopped".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The unique resource identifier of the database
                      account.
                    "name": "str",  # Optional. The name of the database account.
                    "properties": service_resource_properties,
                    "type": "str"  # Optional. The type of Azure resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_service_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            service_name=service_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, service_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_service_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            service_name=service_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def begin_delete(
        self, resource_group_name: str, account_name: str, service_name: str, **kwargs: Any
    ) -> AsyncLROPoller[None]:
        """Deletes service with the given serviceName.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param account_name: Cosmos DB database account name. Required.
        :type account_name: str
        :param service_name: Cosmos DB service name. Required.
        :type service_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns None
        :rtype: ~azure.core.polling.AsyncLROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]
        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                service_name=service_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
